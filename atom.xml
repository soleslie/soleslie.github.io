<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leslie的博客</title>
  
  <subtitle>当你奋力前行时，全世界都会为你让路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://soleslie.github.io/"/>
  <updated>2018-11-30T06:55:54.808Z</updated>
  <id>https://soleslie.github.io/</id>
  
  <author>
    <name>leslie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://soleslie.github.io/2018/11/30/JAVA%E5%B9%B6%E5%8F%91%E6%8C%87%E5%8D%972-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/"/>
    <id>https://soleslie.github.io/2018/11/30/JAVA并发指南2-深入理解Java内存模型JMM/</id>
    <published>2018-11-30T05:51:04.618Z</published>
    <updated>2018-11-30T06:55:54.808Z</updated>
    
    <content type="html"><![CDATA[<div class="post_content"><br>      <p>本文属于作者原创，原文发表于InfoQ：<a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank">http://www.infoq.com/cn/articles/java-memory-model-1</a></p><br><h1>并发编程模型的分类</h1><br><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。<br><br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。<br><br>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br><br>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。<br><br><span id="more-2167"></span></p><br><h1>Java内存模型的抽象</h1><br><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br><br>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：<br><br><a href="http://ifeve.com/wp-content/uploads/2013/01/113.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2273" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/113.png" width="423" height="377" srcset="http://ifeve.com/wp-content/uploads/2013/01/113.png 423w, http://ifeve.com/wp-content/uploads/2013/01/113-300x267.png 300w" sizes="(max-width: 423px) 100vw, 423px"></a><br><br>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：<br><br>1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br><br>2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。<br><br>下面通过示意图来说明这两个步骤：<br><br><a href="http://ifeve.com/wp-content/uploads/2013/01/221.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2275" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/221.png" width="440" height="334" srcset="http://ifeve.com/wp-content/uploads/2013/01/221.png 440w, http://ifeve.com/wp-content/uploads/2013/01/221-300x227.png 300w" sizes="(max-width: 440px) 100vw, 440px"></a><br><br>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br><br>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p><br><h1>重排序</h1><br><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：<br><br>1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br><br>2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br><br>3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br><br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><br><a href="http://ifeve.com/wp-content/uploads/2013/01/331.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2277" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/331.png" width="529" height="76" srcset="http://ifeve.com/wp-content/uploads/2013/01/331.png 529w, http://ifeve.com/wp-content/uploads/2013/01/331-300x43.png 300w" sizes="(max-width: 529px) 100vw, 529px"></a><br><br>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br><br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><br><h1>处理器重排序与内存屏障指令</h1><br><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p><br><table width="500" border="1"><br><tbody><br><tr><br><th>Processor A</th><br><th>Processor B</th><br></tr><br><tr><br><td>a = 1; //A1<br><br>x = b; //A2</td><br><td>b = 2; //B1<br><br>y = a; //B2</td><br></tr><br><tr><br><td colspan="2">初始状态：a = b = 0<br><br>处理器允许执行后得到结果：x = y = 0</td><br></tr><br></tbody><br></table><br><p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：<br><br><a href="http://ifeve.com/wp-content/uploads/2013/01/441.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2279" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/441.png" width="412" height="303" srcset="http://ifeve.com/wp-content/uploads/2013/01/441.png 412w, http://ifeve.com/wp-content/uploads/2013/01/441-300x220.png 300w" sizes="(max-width: 412px) 100vw, 412px"></a><br><br>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。<br><br>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。<br><br>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。<br><br>下面是常见处理器允许的重排序类型的列表：</p><br><table style="width: 514px;height: 127px" width="514" border="1"><br><tbody><br><tr><br><td>&nbsp;</td><br><td>Load-Load</td><br><td>Load-Store</td><br><td>Store-Store</td><br><td>Store-Load</td><br><td>数据依赖</td><br></tr><br><tr><br><td>sparc-TSO</td><br><td>N</td><br><td>N</td><br><td>N</td><br><td>Y</td><br><td>N</td><br></tr><br><tr><br><td>x86</td><br><td>N</td><br><td>N</td><br><td>N</td><br><td>Y</td><br><td>N</td><br></tr><br><tr><br><td>ia64</td><br><td>Y</td><br><td>Y</td><br><td>Y</td><br><td>Y</td><br><td>N</td><br></tr><br><tr><br><td>PowerPC</td><br><td>Y</td><br><td>Y</td><br><td>Y</td><br><td>Y</td><br><td>N</td><br></tr><br></tbody><br></table><br><p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。<br><br>从上表我们可以看出：常见的处理器都允许Store-Load重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。<br><br>※注1：sparc-TSO是指以TSO(Total Store Order)内存模型运行时，sparc处理器的特性。<br><br>※注2：上表中的x86包括x64及AMD64。<br><br>※注3：由于ARM处理器的内存模型与PowerPC处理器的内存模型非常类似，本文将忽略它。<br><br>※注4：数据依赖性后文会专门说明。</p><br><p>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p><br><table style="width: 519px;height: 298px" width="519" border="1"><br><tbody><br><tr><br><td>屏障类型</td><br><td>指令示例</td><br><td>说明</td><br></tr><br><tr><br><td>LoadLoad Barriers</td><br><td>Load1; LoadLoad; Load2</td><br><td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td><br></tr><br><tr><br><td>StoreStore Barriers</td><br><td>Store1; StoreStore; Store2</td><br><td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td><br></tr><br><tr><br><td>LoadStore Barriers</td><br><td>Load1; LoadStore; Store2</td><br><td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td><br></tr><br><tr><br><td>StoreLoad Barriers</td><br><td>Store1; StoreLoad; Load2</td><br><td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td><br></tr><br></tbody><br></table><br><p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><br><h1>happens-before</h1><br><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br><br>与程序员密切相关的happens-before规则如下：</p><br><ul><br><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><br><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><br><li>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</li><br><li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li><br></ul><br><p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before的定义很微妙，后文会具体说明happens-before为什么要这么定义。<br><br>happens-before与JMM的关系如下图所示：</p><br><p>&nbsp;<a href="http://ifeve.com/wp-content/uploads/2013/01/552.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2281" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/552.png" width="511" height="396" srcset="http://ifeve.com/wp-content/uploads/2013/01/552.png 511w, http://ifeve.com/wp-content/uploads/2013/01/552-300x232.png 300w" sizes="(max-width: 511px) 100vw, 511px"></a><br><br>如上图所示，一个happens-before规则通常对应于多个编译器和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><br><h1>参考文献</h1><br><ol><br><li><a href="http://www.amazon.com/Programming-Language-Pragmatics-Third-Michael/dp/0123745144/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1347794595&amp;sr=1-1&amp;keywords=Michael+L.Scott" target="_blank" rel="noopener">Programming Language Pragmatics, Third Edition</a></li><br><li><a href="http://docs.oracle.com/javase/specs/jls/se5.0/jls3.pdf" target="_blank" rel="noopener">The Java Language Specification, Third Edition</a></li><br><li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">JSR-133: Java Memory Model and Thread Specification</a></li><br><li><a href="http://www.ibm.com/developerworks/java/library/j-jtp03304/index.html" target="_blank" rel="noopener">Java theory and practice: Fixing the Java Memory Model, Part 2</a></li><br><li><a href="http://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf" target="_blank" rel="noopener">Understanding POWER Multiprocessors</a></li><br><li><a href="http://www.amazon.com/Concurrent-Programming-Windows-Joe-Duffy/dp/032143482X/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1262571776&amp;sr=1-1" target="_blank" rel="noopener">Concurrent Programming on Windows</a></li><br><li><a href="http://www.amazon.com/Art-Multiprocessor-Programming-Maurice-Herlihy/dp/0123705916/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1248834374&amp;sr=1-1" target="_blank" rel="noopener">The Art of Multiprocessor Programming</a></li><br><li><a href="http://download.intel.com/products/processor/manual/253668.pdf" target="_blank" rel="noopener">Intel® 64 and IA-32 ArchitecturesvSoftware Developer’s Manual Volume 3A: System Programming Guide, Part 1</a></li><br><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">The JSR-133 Cookbook for Compiler Writers</a></li><br></ol><br><h1>关于作者</h1><br><p><strong>程晓明</strong>，Java软件工程师，国家认证的系统分析师、信息项目管理师。专注于并发编程。个人邮箱：<a href="mailto:asst2003@163.com" target="_blank" rel="noopener">asst2003@163.com</a>。</p><br><hr><br><div style="margin-top: 15px; font-style: italic"><br><p><strong>原创文章，转载请注明：</strong> 转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a><strong>本文链接地址:</strong> <a href="http://ifeve.com/java-memory-model-1/" target="_blank" rel="noopener">深入理解Java内存模型（一）——基础</a></p><br></div><br><p><a target="_blank" href="http://www.proxool.cn/"><img src="http://ifeve.com/wp-content/uploads/2018/09/cache-ads.png"><br><br></a></p><br><br>                         <div class="abh_box abh_box_down abh_box_"><ul class="abh_tabs"> <li class="abh_about abh_active"><a href="#abh_about">About</a></li> <li class="abh_posts"><a href="#abh_posts">Latest Posts</a></li></ul><div class="abh_tab_content"><section class="vcard abh_about_tab abh_tab" style="display:block"><div class="abh_image"><a href="http://ifeve.com/author/25622818/" class="url" title="程晓明" target="_blank" rel="noopener"><img alt="" src="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=80&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=160&amp;d=mm&amp;r=g 2x" class="avatar avatar-80 photo" height="80" width="80"></a></div><div class="abh_social"> </div><div class="abh_text"><h3 class="fn name"><a href="http://ifeve.com/author/25622818/" class="url" target="_blank" rel="noopener">程晓明</a></h3><div class="abh_job"></div><div class="description note abh_description">程晓明，Java软件工程师，专注于并发编程，就职于富士通南大。个人邮箱：<a href="mailto:asst2003@163.com" target="_blank" rel="noopener">asst2003@163.com</a>。</div></div> </section><section class="abh_posts_tab abh_tab"><div class="abh_image"><a href="http://ifeve.com/author/25622818/" class="url" title="程晓明" target="_blank" rel="noopener"><img alt="" src="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=80&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=160&amp;d=mm&amp;r=g 2x" class="avatar avatar-80 photo" height="80" width="80"></a></div><div class="abh_social"> </div><div class="abh_text"><h4>Latest posts by 程晓明 <span class="abh_allposts">(<a href="http://ifeve.com/author/25622818/" target="_blank" rel="noopener">see all</a>)</span></h4><div class="abh_description note"><ul>                <li>                    <a href="http://ifeve.com/double-checked-locking-with-delay-initialization/" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a><span> - 2013年10月10日</span>                </li>               <li>                    <a href="http://ifeve.com/java-memory-model-7/" target="_blank" rel="noopener">深入理解Java内存模型（七）——总结</a><span> - 2013年3月16日</span>               </li>               <li>                    <a href="http://ifeve.com/java-memory-model/" target="_blank" rel="noopener">深入理解Java内存模型（六）——final</a><span> - 2013年3月10日</span>              </li></ul></div></div> </section></div> </div><span class="wpfp-span"><img src="http://ifeve.com/wp-content/plugins/wp-favorite-posts/img/star.png" alt="Favorite" title="Favorite" class="wpfp-img"><img src="http://ifeve.com/wp-content/plugins/wp-favorite-posts/img/loading.gif" alt="Loading" title="Loading" class="wpfp-hide wpfp-img"><a class="wpfp-link" href="?wpfpaction=add&amp;postid=2167" title="添加本文到我的收藏" rel="nofollow">添加本文到我的收藏</a></span><div class="yarpp-related"><br><h3>Related posts:</h3><ol><br><li><a href="http://ifeve.com/java-memory-model-7/" rel="noopener" title="深入理解Java内存模型（七）——总结" target="_blank">深入理解Java内存模型（七）——总结 </a></li><br><li><a href="http://ifeve.com/java-memory-model-2/" rel="noopener" title="深入理解Java内存模型（二）——重排序" target="_blank">深入理解Java内存模型（二）——重排序 </a></li><br><li><a href="http://ifeve.com/java-memory-model-5/" rel="noopener" title="深入理解Java内存模型（五）——锁" target="_blank">深入理解Java内存模型（五）——锁 </a></li><br><li><a href="http://ifeve.com/java-memory-model-3/" rel="noopener" title="深入理解Java内存模型（三）——顺序一致性" target="_blank">深入理解Java内存模型（三）——顺序一致性 </a></li><br><li><a href="http://ifeve.com/java-memory-model-4/" rel="noopener" title="深入理解Java内存模型（四）——volatile" target="_blank">深入理解Java内存模型（四）——volatile </a></li><br><li><a href="http://ifeve.com/java-memory-model/" rel="noopener" title="深入理解Java内存模型（六）——final" target="_blank">深入理解Java内存模型（六）——final </a></li><br><li><a href="http://ifeve.com/java-memory-model-0/" rel="noopener" title="深入理解java内存模型系列文章" target="_blank">深入理解java内存模型系列文章 </a></li><br><li><a href="http://ifeve.com/jmm-cookbook-mb/" rel="noopener" title="Java内存模型Cookbook（二）内存屏障" target="_blank">Java内存模型Cookbook（二）内存屏障 </a></li><br><li><a href="http://ifeve.com/memory-barriersfences/" rel="noopener" title="Memory Barriers/Fences" target="_blank">Memory Barriers/Fences </a></li><br><li><a href="http://ifeve.com/jmm-cookbook-mps/" rel="noopener" title="Java内存模型Cookbook(三)多处理器" target="_blank">Java内存模型Cookbook(三)多处理器 </a></li><br><li><a href="http://ifeve.com/cookbook-recipes/" rel="noopener" title="Java内存模型Cookbook（四）指南(Recipes)" target="_blank">Java内存模型Cookbook（四）指南(Recipes) </a></li><br><li><a href="http://ifeve.com/how-to-use-volatile/" rel="noopener" title="Java并发中正确使用volatile" target="_blank">Java并发中正确使用volatile </a></li><br><li><a href="http://ifeve.com/talk-to-my-understanding-of-the-java-memory-model/" rel="noopener" title="聊聊我对Java内存模型的理解" target="_blank">聊聊我对Java内存模型的理解 </a></li><br><li><a href="http://ifeve.com/jsr133/" rel="noopener" title="Java内存模型FAQ（三）JSR133是什么？" target="_blank">Java内存模型FAQ（三）JSR133是什么？ </a></li><br><li><a href="http://ifeve.com/paper-set/" rel="noopener" title="并发网系列文章集" target="_blank">并发网系列文章集 </a></li><br></ol><br></div><br>           </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;post_content&quot;&gt;&lt;br&gt;      &lt;p&gt;本文属于作者原创，原文发表于InfoQ：&lt;a href=&quot;http://www.infoq.com/cn/articles/java-memory-model-1&quot; target=&quot;_blank&quot;&gt;ht
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA并发指南1-Java多线程与并发基础</title>
    <link href="https://soleslie.github.io/2018/11/30/JAVA%E5%B9%B6%E5%8F%91%E6%8C%87%E5%8D%971-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://soleslie.github.io/2018/11/30/JAVA并发指南1-Java多线程与并发基础/</id>
    <published>2018-11-30T05:25:58.000Z</published>
    <updated>2018-11-30T06:40:17.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h1><p>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。</p><p>随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。<br><a id="more"></a><br>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。</p><p>多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行。</p><p>如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。</p><p>Java的多线程和并发性<br>Java是最先支持多线程的开发的语言之一，Java从一开始就支持了多线程能力，因此Java开发者能常遇到上面描述的问题场景。这也是我想为Java并发技术而写这篇系列的原因。作为对自己的笔记，和对其他Java开发的追随者都可获益的。</p><p>该系列主要关注Java多线程，但有些在多线程中出现的问题会和多任务以及分布式系统中出现的存在类似，因此该系列会将多任务和分布式系统方面作为参考，所以叫法上称为“并发性”，而不是“多线程”。</p><h1 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h1><p>尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是：</p><h2 id="资源利用率更好"><a href="#资源利用率更好" class="headerlink" title="资源利用率更好"></a>资源利用率更好</h2><p>程序设计在某些情况下更简单<br>程序响应更快<br>资源利用率更好<br>想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1   5`秒读取文件A`</span><br><span class="line">2   2`秒处理文件A`</span><br><span class="line">3   5`秒读取文件B`</span><br><span class="line">4   2`秒处理文件B`</span><br><span class="line">5   ---------------------</span><br><span class="line">6   总共需要`14秒`</span><br></pre></td></tr></table></figure></p><p>从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1   5`秒读取文件A`</span><br><span class="line">2   5`秒读取文件B + 2秒处理文件A`</span><br><span class="line">3   2`秒处理文件B`</span><br><span class="line">4   ---------------------</span><br><span class="line">5   总共需要`12秒`</span><br></pre></td></tr></table></figure><p>CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。</p><p>总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。</p><h2 id="程序设计更简单"><a href="#程序设计更简单" class="headerlink" title="程序设计更简单"></a>程序设计更简单</h2><p>在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。</p><h2 id="程序响应更快"><a href="#程序响应更快" class="headerlink" title="程序响应更快"></a>程序响应更快</h2><p>将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。服务器的流程如下所述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(server is active) &#123;</span><br><span class="line">    listen forrequest</span><br><span class="line">    process request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(server is active)&#123;</span><br><span class="line">    listen forrequest</span><br><span class="line">    hand request to worker thread</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。</p><p>桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（word thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。</p><h1 id="多线程的代价"><a href="#多线程的代价" class="headerlink" title="多线程的代价"></a>多线程的代价</h1><p>从一个单线程的应用到一个多线程的应用并不仅仅带来好处，它也会有一些代价。不要仅仅为了使用多线程而使用多线程。而应该明确在使用多线程时能多来的好处比所付出的代价大的时候，才使用多线程。如果存在疑问，应该尝试测量一下应用程序的性能和响应能力，而不只是猜测。</p><h2 id="设计更复杂"><a href="#设计更复杂" class="headerlink" title="设计更复杂"></a>设计更复杂</h2><p>虽然有一些多线程应用程序比单线程的应用程序要简单，但其他的一般都更复杂。在多线程访问共享数据的时候，这部分代码需要特别的注意。线程之间的交互往往非常复杂。不正确的线程同步产生的错误非常难以被发现，并且重现以修复。</p><h2 id="上下文切换的开销"><a href="#上下文切换的开销" class="headerlink" title="上下文切换的开销"></a>上下文切换的开销</h2><p>当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。</p><p>上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生。</p><p>你可以通过维基百科阅读更多的关于上下文切换相关的内容：</p><p><a href="http://en.wikipedia.org/wiki/Context_switch" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Context_switch</a></p><h2 id="增加资源消耗"><a href="#增加资源消耗" class="headerlink" title="增加资源消耗"></a>增加资源消耗</h2><p>线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程。我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。</p><h1 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h1><h2 id="线程与多线程"><a href="#线程与多线程" class="headerlink" title="线程与多线程"></a>线程与多线程</h2><p>线程是什么？<br>线程（Thread）是一个对象（Object）。用来干什么？Java 线程（也称 JVM 线程）是 Java 进程内允许多个同时进行的任务。该进程内并发的任务成为线程（Thread），一个进程里至少一个线程。</p><p>Java 程序采用多线程方式来支持大量的并发请求处理，程序如果在多线程方式执行下，其复杂度远高于单线程串行执行。那么多线程：指的是这个程序（一个进程）运行时产生了不止一个线程。</p><p>为啥使用多线程？</p><p>适合多核处理器。一个线程运行在一个处理器核心上，那么多线程可以分配到多个处理器核心上，更好地利用多核处理器。<br>防止阻塞。将数据一致性不强的操作使用多线程技术（或者消息队列）加快代码逻辑处理，缩短响应时间。<br>聊到多线程，多半会聊并发与并行，咋理解并区分这两个的区别呢？</p><p>类似单个 CPU ，通过 CPU 调度算法等，处理多个任务的能力，叫并发<br>类似多个 CPU ，同时并且处理相同多个任务的能力，叫做并行</p><h2 id="线程的运行与创建"><a href="#线程的运行与创建" class="headerlink" title="线程的运行与创建"></a>线程的运行与创建</h2><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>Java 创建线程对象有两种方法：</p><p>继承 Thread 类创建线程对象<br>实现 Runnable 接口类创建线程对象<br>新建 MyThread 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承 Thread 类创建线程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年01月27日21:03:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread 的线程对象正在执行任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"MyThread 的线程对象 "</span> + thread.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyThread 类继承了 Thread 对象，并重写（Override）了 run 方法，实现线程里面的逻辑。main 函数是使用 for 语句，循环创建了 10 个线程，调用 start 方法启动线程，最后打印当前线程对象的 ID。</p><p>run 方法和 start 方法的区别是什么呢？<br>run 方法就是跑的意思，线程启动后，会调用 run 方法。<br>start 方法就是启动的意思，就是启动新线程实例。启动线程后，才会调线程的 run 方法。</p><p>执行 main 方法后，控制台打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 10</span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 11</span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 12</span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 13</span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 14</span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 15</span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 16</span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 17</span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 18</span><br><span class="line">MyThread 的线程对象正在执行任务</span><br><span class="line">MyThread 的线程对象 19</span><br></pre></td></tr></table></figure></p><p>可见，线程的 ID 是线程唯一标识符，每个线程 ID 都是不一样的。</p><p>同理，实现 Runnable 接口类创建线程对象也很简单，只是不同的形式。新建 MyThreadBrother 代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Runnable 接口类创建线程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年01月27日21:22:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadBrother</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThreadBrother 的线程对象正在执行任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThreadBrother());</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"MyThreadBrother 的线程对象 "</span> + thread.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程的运行"><a href="#线程的运行" class="headerlink" title="线程的运行"></a>线程的运行</h3><p>在运行上面两个小 demo 后，JVM 执行了 main 函数线程，然后在主线程中执行创建了新的线程。正常情况下，所有线程执行到运行结束为止。除非某个线程中调用了 System.exit(1) 则被终止。</p><p>在实际开发中，一个请求到响应式是一个线程。但在这个线程中可以使用线程池创建新的线程，去执行任务。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>新建 MyThreadInfo 类，打印线程对象属性，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程实例对象的属性值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年01月27日21:24:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadInfo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThreadInfo 的线程实例正在执行任务"</span>);</span><br><span class="line"><span class="comment">//        System.exit(1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadInfo thread = <span class="keyword">new</span> MyThreadInfo();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"MyThreadInfo 的线程对象 \n"</span></span><br><span class="line">                + <span class="string">"线程唯一标识符："</span> + thread.getId() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"线程名称："</span> + thread.getName() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"线程状态："</span> + thread.getState() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"线程优先级："</span> + thread.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyThreadInfo 的线程实例正在执行任务</span><br><span class="line">MyThreadInfo 的线程对象 </span><br><span class="line">线程唯一标识符：10</span><br><span class="line">线程名称：Thread-0</span><br><span class="line">线程状态：NEW</span><br><span class="line">线程优先级：5</span><br></pre></td></tr></table></figure><p>线程是一个对象，它有唯一标识符ID、名称、状态、优先级等属性。线程只能修改其优先级和名称等属性 ，无法修改 ID  、状态。ID 是 JVM 分配的。名称默认也为<br>Thread-XX，XX是一组数字。线程初始状态为 NEW。</p><p>线程优先级的范围是 1 到 10 ，其中 1 是最低优先级，10 是最高优先级。不推荐改变线程的优先级，如果业务需要，自然可以修改线程优先级到最高，或者最低。</p><p>线程的状态实现通过 Thread.State 常量类实现，有 6 种线程状态：new（新建）、runnnable（可运行）、blocked（阻塞）、waiting（等待）、time waiting （定时等待）和 terminated（终止）。</p><p>线程状态流程大致如下：</p><p>线程创建后，进入 new 状态<br>调用 start 或者 run 方法，进入 runnable 状态<br>JVM 按照线程优先级及时间分片等执行 runnable 状态的线程。开始执行时，进入 running 状态<br>如果线程执行 sleep、wait、join，或者进入 IO 阻塞等。进入 wait 或者 blocked 状态<br>线程执行完毕后，线程被线程队列移除。最后为 terminated 状态。</p><h2 id="线程中断和终止"><a href="#线程中断和终止" class="headerlink" title="线程中断和终止"></a>线程中断和终止</h2><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><h4 id="什么是线程中断？"><a href="#什么是线程中断？" class="headerlink" title="什么是线程中断？"></a>什么是线程中断？</h4><p>线程中断是线程的标志位属性。而不是真正终止线程，和线程的状态无关。线程中断过程表示一个运行中的线程，通过其他线程调用了该线程的 interrupt() 方法，使得该线程中断标志位属性改变。</p><p>深入思考下，线程中断不是去中断了线程，恰恰是用来通知该线程应该被中断了。具体是一个标志位属性，到底该线程生命周期是去终止，还是继续运行，由线程根据标志位属性自行处理。</p><h4 id="线程中断操作"><a href="#线程中断操作" class="headerlink" title="线程中断操作"></a>线程中断操作</h4><p>调用线程的 interrupt() 方法，根据线程不同的状态会有不同的结果。</p><p>下面新建 InterruptedThread 对象，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一直运行的线程，中断状态为 true</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年02月23日19:03:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptedThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直 run</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread interruptedThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InterruptedThread(), <span class="string">"InterruptedThread"</span>);</span><br><span class="line">        interruptedThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        interruptedThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"InterruptedThread interrupted is "</span> + interruptedThread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行 main 函数，结果如下：</p><pre><code>InterruptedThread interrupted is true</code></pre><p>代码详解：<br>线程一直在运行状态，没有停止或者阻塞等<br>调用了 interrupt() 方法，中断状态置为 true，但不会影响线程的继续运行</p><p>另一种情况，新建 InterruptedException 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抛出 InterruptedException 的线程，中断状态被重置为默认状态 false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年02月23日19:03:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptedException</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一直 sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread interruptedThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InterruptedException(), <span class="string">"InterruptedThread"</span>);</span><br><span class="line">        interruptedThread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中断被阻塞状态（sleep、wait、join 等状态）的线程，会抛出异常 InterruptedException</span></span><br><span class="line">        <span class="comment">// 在抛出异常 InterruptedException 前，JVM 会先将中断状态重置为默认状态 false</span></span><br><span class="line">        interruptedThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"InterruptedThread interrupted is "</span> + interruptedThread.isInterrupted());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main 函数，结果如下：</p><pre><code>InterruptedThread interrupted is falsejava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)</code></pre><p>代码详解：<br>中断被阻塞状态（sleep、wait、join 等状态）的线程，会抛出异常 InterruptedException<br>抛出异常 InterruptedException 前，JVM 会先将中断状态重置为默认状态 false<br>小结下线程中断：<br>线程中断，不是停止线程，只是一个线程的标志位属性<br>如果线程状态为被阻塞状态（sleep、wait、join 等状态），线程状态退出被阻塞状态，抛出异常 InterruptedException，并重置中断状态为默认状态 false<br>如果线程状态为运行状态，线程状态不变，继续运行，中断状态置为 true。</p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>比如在 IDEA 中强制关闭程序，立即停止程序，不给程序释放资源等操作，肯定是不正确的。线程终止也存在类似的问题，所以需要考虑如何终止线程？</p><p>上面聊到了线程中断，可以利用线程中断标志位属性来安全终止线程。同理也可以使用 boolean 变量来控制是否需要终止线程。</p><p>新建 ，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全终止线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeff Lee @ bysocket.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018年02月23日19:03:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeStop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠 1 秒，通知 CountThread 中断，并终止线程</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two,<span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠 1 秒，然后设置线程停止状态，并终止线程</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.stopSafely();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="comment">// 线程执行具体逻辑</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Count i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，通过 while (on &amp;&amp; !Thread.currentThread().isInterrupted()) 代码来实现线程是否跳出执行逻辑，并终止。但是疑问点就来了，为啥需要 on 和 isInterrupted() 两项一起呢？用其中一个方式不就行了吗？答案在下面</p><p>线程成员变量 on 通过 volatile 关键字修饰，达到线程之间可见，从而实现线程的终止。但当线程状态为被阻塞状态（sleep、wait、join 等状态）时，对成员变量操作也阻塞，进而无法执行安全终止线程<br>为了处理上面的问题，引入了 isInterrupted(); 只去解决阻塞状态下的线程安全终止。<br>两者结合是真的没问题了吗？不是的，如果是网络 io 阻塞，比如一个 websocket 一直再等待响应，那么直接使用底层的 close 。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>很多好友介绍，如果用 Spring 栈开发到使用线程或者线程池，那么尽量使用框架这块提供的线程操作及框架提供的终止等</p><h1 id="竞态条件与临界区"><a href="#竞态条件与临界区" class="headerlink" title="竞态条件与临界区"></a>竞态条件与临界区</h1><p>在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。</p><p>多线程同时执行下面的代码可能会出错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(`longvalue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="keyword">this</span>.count + value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序：</p><p>从内存获取 this.count 的值放到寄存器<br>将寄存器中的值增加value<br>将寄存器中的值写回内存<br>观察线程A和B交错执行会发生什么：</p><pre><code>this.count = 0;</code></pre><p>   A:    读取 this.count 到一个寄存器 (0)<br>   B:    读取 this.count 到一个寄存器 (0)<br>   B:     将寄存器的值加2<br>   B:    回写寄存器值(2)到内存. this.count 现在等于 2<br>   A:    将寄存器的值加3<br>   A:    回写寄存器值(3)到内存. this.count 现在等于 3</p><p>两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。</p><h2 id="竞态条件-amp-临界区"><a href="#竞态条件-amp-临界区" class="headerlink" title="竞态条件&amp;临界区"></a>竞态条件&amp;临界区</h2><p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。</p><h1 id="线程安全与共享资源"><a href="#线程安全与共享资源" class="headerlink" title="线程安全与共享资源"></a>线程安全与共享资源</h1><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。</p><h2 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h2><p>对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。如果在某个方法中创建的对象不会逃逸出（译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到）该方法，那么它就是线程安全的。实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalObject localObject = newLocalObject();</span><br><span class="line">    localObject.callMethod();</span><br><span class="line">    method2(localObject);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(LocalObject localObject)</span></span>&#123;</span><br><span class="line">    localObject.setValue(“value”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了。</p><h2 id="对象成员"><a href="#对象成员" class="headerlink" title="对象成员"></a>对象成员</h2><p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotThreadSafe</span></span>&#123;</span><br><span class="line">    StringBuilder builder = newStringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">add</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder.append(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    NotThreadSafe sharedInstance = newNotThreadSafe();</span><br><span class="line">    <span class="keyword">new</span> Thread(newMyRunnable(sharedInstance)).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(newMyRunnable(sharedInstance)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implementsRunnable</span> </span>&#123;</span><br><span class="line">    NotThreadSafe instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(NotThreadSafe instance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instance.add(<span class="string">"some text"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。</p><p>当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子：</p><pre><code>new Thread(newMyRunnable(newNotThreadSafe())).start();new Thread(newMyRunnable(newNotThreadSafe())).start();</code></pre><p>现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。</p><h2 id="线程控制逃逸规则"><a href="#线程控制逃逸规则" class="headerlink" title="线程控制逃逸规则"></a>线程控制逃逸规则</h2><p>线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。</p><p>如果一个资源的创建，使用，销毁都在同一个线程内完成，<br>且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。<br>资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。</p><p>即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。比如，2个线程执行如下代码：</p><p>检查记录X是否存在，如果不存在，插入X<br>如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录：</p><p>线程1检查记录X是否存在。检查结果：不存在<br>线程2检查记录X是否存在。检查结果：不存在<br>线程1插入记录X<br>线程2插入记录X<br>同样的问题也会发生在文件或其他共享资源上。因此，区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要。</p><h1 id="线程安全及不可变性"><a href="#线程安全及不可变性" class="headerlink" title="线程安全及不可变性"></a>线程安全及不可变性</h1><p>当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生竞态条件。多个线程同时读同一个资源不会产生竞态条件。</p><p>我们可以通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意ImmutableValue类的成员变量value是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。</p><p>（译者注：注意，“不变”（Immutable）和“只读”（Read Only）是不同的。当一个变量是“只读”时，变量的值不能直接改变，但是可以在其它变量发生改变的时候发生改变。比如，一个人的出生年月日是“不变”属性，而一个人的年龄便是“只读”属性，但是不是“不变”属性。随着时间的变化，一个人的年龄会随之发生变化，而一个人的出生年月日则不会变化。这就是“不变”和“只读”的区别。（摘自《Java与模式》第34章））</p><p>如果你需要对ImmutableValue类的实例进行操作，可以通过得到value变量后创建一个新的实例来实现，下面是一个对value变量进行加法操作的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableValue</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ImmutableValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ImmutableValue <span class="title">add</span><span class="params">(<span class="keyword">int</span> valueToAdd)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ImmutableValue(<span class="keyword">this</span>.value + valueToAdd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意add()方法以加法操作的结果作为一个新的ImmutableValue类实例返回，而不是直接对它自己的value变量进行操作。</p><h2 id="引用不是线程安全的！"><a href="#引用不是线程安全的！" class="headerlink" title="引用不是线程安全的！"></a>引用不是线程安全的！</h2><p>重要的是要记住，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。看这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Calculator&#123;</span><br><span class="line">    <span class="keyword">private</span> ImmutableValue currentValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImmutableValue <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> currentValue;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(ImmutableValue newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentValue = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentValue = <span class="keyword">this</span>.currentValue.add(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。</p><p>要使Calculator类实现线程安全，将getValue()、setValue()和add()方法都声明为同步方法即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是并发&quot;&gt;&lt;a href=&quot;#什么是并发&quot; class=&quot;headerlink&quot; title=&quot;什么是并发&quot;&gt;&lt;/a&gt;什么是并发&lt;/h1&gt;&lt;p&gt;在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。&lt;/p&gt;
&lt;p&gt;随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。&lt;br&gt;
    
    </summary>
    
      <category term="Java并发指南" scheme="https://soleslie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="Java并发" scheme="https://soleslie.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://soleslie.github.io/2018/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://soleslie.github.io/2018/11/30/计算机网络/</id>
    <published>2018-11-30T01:38:34.000Z</published>
    <updated>2018-11-30T06:41:21.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-HTTP各个版本之间的区别"><a href="#1-HTTP各个版本之间的区别" class="headerlink" title="1. HTTP各个版本之间的区别"></a>1. HTTP各个版本之间的区别</h1><h2 id="HTTP1-0和HTTP1-1之间的区别"><a href="#HTTP1-0和HTTP1-1之间的区别" class="headerlink" title="HTTP1.0和HTTP1.1之间的区别"></a>HTTP1.0和HTTP1.1之间的区别</h2><h3 id="1-连接方面"><a href="#1-连接方面" class="headerlink" title="(1) 连接方面"></a>(1) 连接方面</h3><p>HTTP1.0使用的是非持久连接，即一个tcp连接只传输一个web对象，每次请求和响应都需要单独建立一个连接，每次连接只是传输一个对象，严重影响客户端和服务端的性能。</p><p>HTTP1.1默认采用的是持久连接(也可以自己定义为非持久连接)，在持久化连接下不必为每个web对象的传送建立一个新的连接，一个tcp连接可以传输多个web对象，在一个tcp连接上可以传输多个http请求和响应，减少了建立连接和关闭连接的小号和延迟。</p><h3 id="2-缓存方面"><a href="#2-缓存方面" class="headerlink" title="(2) 缓存方面"></a>(2) 缓存方面</h3><p>HTTP1.0主要使用header里面的If-Modified-Since，Expires来做为缓存的判断标准。</p><p>HTTP则引入更多的缓存控制策略，如Entity tag，If-Unmodified-Since,If-Match,If-None-Match等更多可供选择的缓存头来控制缓存策略带宽优化及网络连接的使用。</p><h3 id="3-状态码"><a href="#3-状态码" class="headerlink" title="(3) 状态码"></a>(3) 状态码</h3><p>HTTP1.1新增了24个错误状态响应码。</p><h3 id="4-带宽优化"><a href="#4-带宽优化" class="headerlink" title="(4) 带宽优化"></a>(4) 带宽优化</h3><p>HTTP1.1支持只发送header信息，如果服务器端认为客户端有权限请求服务器，返回100，否侧返回401。客户端收到100，才开始把请求body发送到服务器端，如果是401，则不用发送请求body了，节省了带宽。</p><h3 id="5-Host头"><a href="#5-Host头" class="headerlink" title="(5) Host头"></a>(5) Host头</h3><p>HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</p><p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><h2 id="HTTP1-1和HTTP2-0的区别"><a href="#HTTP1-1和HTTP2-0的区别" class="headerlink" title="HTTP1.1和HTTP2.0的区别"></a>HTTP1.1和HTTP2.0的区别</h2><h3 id="1-多路复用"><a href="#1-多路复用" class="headerlink" title="(1) 多路复用"></a>(1) 多路复用</h3><p>在HTTP不支持1.1协议中，浏览器客户端在同一时间针对同一域名的请求有一定数据限制。超过限制数目的请求会被阻塞。<br>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><h2 id="2-首部压缩"><a href="#2-首部压缩" class="headerlink" title="(2) 首部压缩"></a>(2) 首部压缩</h2><p>HTTP1.1不支持headers数据的压缩，HTTP使用HPACK算法对header的数据进行压缩，这样数据更小了，传输就会更快。</p><h2 id="3-服务端推送"><a href="#3-服务端推送" class="headerlink" title="(3) 服务端推送"></a>(3) 服务端推送</h2><p>HTTP2.0当客户端对服务器端请求数据时，服务器端会顺便把客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务端获取数据，这种方式非常适合加载静态资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-HTTP各个版本之间的区别&quot;&gt;&lt;a href=&quot;#1-HTTP各个版本之间的区别&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP各个版本之间的区别&quot;&gt;&lt;/a&gt;1. HTTP各个版本之间的区别&lt;/h1&gt;&lt;h2 id=&quot;HTTP1-0和HTT
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://soleslie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://soleslie.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解7-set家族</title>
    <link href="https://soleslie.github.io/2018/11/28/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A37-set%E5%AE%B6%E6%97%8F/"/>
    <id>https://soleslie.github.io/2018/11/28/Java集合详解/Java集合详解7-set家族/</id>
    <published>2018-11-28T03:14:58.000Z</published>
    <updated>2018-11-28T03:19:01.224Z</updated>
    
    <content type="html"><![CDATA[<p>抓准核心，HashSet、LinkedHashSet和TreeSet分别是基于对应的三种map实现，利用了map键不能重复的特点，实现set不能包含重复元素的特点，所以重点是理解map。<br>传送门[<a href="https://h2pl.github.io/2018/05/12/collection7/]" target="_blank" rel="noopener">https://h2pl.github.io/2018/05/12/collection7/]</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;抓准核心，HashSet、LinkedHashSet和TreeSet分别是基于对应的三种map实现，利用了map键不能重复的特点，实现set不能包含重复元素的特点，所以重点是理解map。&lt;br&gt;传送门[&lt;a href=&quot;https://h2pl.github.io/2018
      
    
    </summary>
    
      <category term="Java集合详解" scheme="https://soleslie.github.io/categories/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="Java集合" scheme="https://soleslie.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解6-TreeMap和红黑树</title>
    <link href="https://soleslie.github.io/2018/11/28/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A36-TreeMap%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://soleslie.github.io/2018/11/28/Java集合详解/Java集合详解6-TreeMap和红黑树/</id>
    <published>2018-11-28T02:25:41.000Z</published>
    <updated>2018-11-28T05:37:16.201Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树真的有点难，理解都有点苦难，等自己把树的知识打扎实之后，我会回来的。<br>原文出处<br><a href="http://www.cnblogs.com/xrq730/p/6867924.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/6867924.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;红黑树真的有点难，理解都有点苦难，等自己把树的知识打扎实之后，我会回来的。&lt;br&gt;原文出处&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/xrq730/p/6867924.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ht
      
    
    </summary>
    
      <category term="Java集合详解" scheme="https://soleslie.github.io/categories/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="Java集合" scheme="https://soleslie.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解5:深入理解LinkedHashMap和LRU缓存</title>
    <link href="https://soleslie.github.io/2018/11/28/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A35-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3LinkedHashMap%E5%92%8CLRU%E7%BC%93%E5%AD%98/"/>
    <id>https://soleslie.github.io/2018/11/28/Java集合详解/Java集合详解5-深入理解LinkedHashMap和LRU缓存/</id>
    <published>2018-11-28T02:14:22.000Z</published>
    <updated>2018-11-28T02:23:35.677Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://h2pl.github.io/2018/05/11/collection5/" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/11/collection5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java集合详解" scheme="https://soleslie.github.io/categories/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="Java集合" scheme="https://soleslie.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统</title>
    <link href="https://soleslie.github.io/2018/11/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://soleslie.github.io/2018/11/27/计算机操作系统/</id>
    <published>2018-11-27T02:17:58.000Z</published>
    <updated>2018-11-27T04:03:16.794Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md" target="_blank" rel="noopener">本文参考自</a><br><!-- GFM-TOC --></p><ul><li><a href="#一概述">一、概述</a><ul><li><a href="#基本特征">基本特征</a></li><li><a href="#基本功能">基本功能</a></li><li><a href="#系统调用">系统调用</a></li><li><a href="#大内核和微内核">大内核和微内核</a></li><li><a href="#中断分类">中断分类</a></li></ul></li><li><a href="#二进程管理">二、进程管理</a><ul><li><a href="#进程与线程">进程与线程</a></li><li><a href="#进程状态的切换">进程状态的切换</a></li><li><a href="#进程调度算法">进程调度算法</a></li><li><a href="#进程同步">进程同步</a></li><li><a href="#经典同步问题">经典同步问题</a></li><li><a href="#进程通信">进程通信</a></li></ul></li><li><a href="#三死锁">三、死锁</a><ul><li><a href="#必要条件">必要条件</a></li><li><a href="#处理方法">处理方法</a></li><li><a href="#鸵鸟策略">鸵鸟策略</a></li><li><a href="#死锁检测与死锁恢复">死锁检测与死锁恢复</a></li><li><a href="#死锁预防">死锁预防</a></li><li><a href="#死锁避免">死锁避免</a></li></ul></li><li><a href="#四内存管理">四、内存管理</a><ul><li><a href="#虚拟内存">虚拟内存</a></li><li><a href="#分页系统地址映射">分页系统地址映射</a></li><li><a href="#页面置换算法">页面置换算法</a></li><li><a href="#分段">分段</a></li><li><a href="#段页式">段页式</a></li><li><a href="#分页与分段的比较">分页与分段的比较</a></li></ul></li><li><a href="#五设备管理">五、设备管理</a><ul><li><a href="#磁盘结构">磁盘结构</a></li><li><a href="#磁盘调度算法">磁盘调度算法</a></li></ul></li><li><a href="#六链接">六、链接</a><ul><li><a href="#编译系统">编译系统</a></li><li><a href="#静态链接">静态链接</a></li><li><a href="#目标文件">目标文件</a></li><li><a href="#动态链接">动态链接</a></li></ul></li><li><a href="#常见面试题">七、常见面试题</a><!-- GFM-TOC --></li></ul><a id="more"></a><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线或者多处理器。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。</p><h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时分复用技术和空分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间和物理内存使用页进行交换，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th style="text-align:center">Task</th><th>Commands</th></tr></thead><tbody><tr><td style="text-align:center">进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td style="text-align:center">进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td style="text-align:center">文件操作</td><td>open(); read(); write();</td></tr><tr><td style="text-align:center">设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td style="text-align:center">信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td style="text-align:center">安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><h3 id="1-大内核"><a href="#1-大内核" class="headerlink" title="1. 大内核"></a>1. 大内核</h3><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p><h1 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>进程是资源分配的基本单位。</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>线程是独立调度的基本单位。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><p>Ⅰ 拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>Ⅱ 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>Ⅲ 系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>Ⅳ 通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p><h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong> </p><p>按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>1.2 短作业优先 shortest job first（SJF）</strong> </p><p>按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong> </p><p>按估计剩余时间最短的顺序进行调度。</p><h3 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><p><strong>2.1 时间片轮转</strong> </p><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><p><strong>2.2 优先级调度</strong> </p><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p><strong>2.3 多级反馈队列</strong> </p><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><h3 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul><li>同步：多个进程按一定顺序执行；</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong>  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了  <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="3">  <strong>使用信号量实现生产者-消费者问题</strong>  </font> <br></p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><p><a href="https://blog.csdn.net/u010983881/article/details/78554671" target="_blank" rel="noopener">生产者消费者的Java实现</a></p><h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。</p><p>管程引入了  <strong>条件变量</strong>  以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><p><font size="3"> <strong>使用管程实现生产者-消费者问题</strong> </font><br></p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><p>生产者和消费者问题前面已经讨论过了。</p><h3 id="1-读者-写者问题"><a href="#1-读者-写者问题" class="headerlink" title="1. 读者-写者问题"></a>1. 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下内容由 <a href="https://github.com/yugandharbandi" target="_blank" rel="noopener">@Bandi Yugandhar</a> 提供。</p><p>The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">int readcount, writecount;                   //(initial value = 0)</span><br><span class="line">semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)</span><br><span class="line"></span><br><span class="line">//READER</span><br><span class="line">void reader() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line"> down(&amp;readLock);                 //  reader is trying to enter</span><br><span class="line"> down(&amp;rmutex);                  //   lock to increase readcount</span><br><span class="line">  readcount++;                 </span><br><span class="line">  if (readcount == 1)          </span><br><span class="line">   down(&amp;resource);              //if you are the first reader then lock  the resource</span><br><span class="line"> up(&amp;rmutex);                  //release  for other readers</span><br><span class="line"> up(&amp;readLock);                 //Done with trying to access the resource</span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line">//reading is performed</span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line"> down(&amp;rmutex);                  //reserve exit section - avoids race condition with readers</span><br><span class="line"> readcount--;                       //indicate you&apos;re leaving</span><br><span class="line">  if (readcount == 0)          //checks if you are last reader leaving</span><br><span class="line">   up(&amp;resource);              //if last, you must release the locked resource</span><br><span class="line"> up(&amp;rmutex);                  //release exit section for other readers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//WRITER</span><br><span class="line">void writer() &#123;</span><br><span class="line">  &lt;ENTRY Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  //reserve entry section for writers - avoids race conditions</span><br><span class="line">  writecount++;                //report yourself as a writer entering</span><br><span class="line">  if (writecount == 1)         //checks if you&apos;re first writer</span><br><span class="line">   down(&amp;readLock);               //if you&apos;re first, then you must lock the readers out. Prevent them from trying to enter CS</span><br><span class="line">  up(&amp;wmutex);                  //release entry section</span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"> down(&amp;resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource</span><br><span class="line">  //writing is performed</span><br><span class="line"> up(&amp;resource);                //release file</span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  //reserve exit section</span><br><span class="line">  writecount--;                //indicate you&apos;re leaving</span><br><span class="line">  if (writecount == 0)         //checks if you&apos;re the last writer</span><br><span class="line">   up(&amp;readLock);               //if you&apos;re last writer, you must unlock the readers. Allows them to try enter CS for reading</span><br><span class="line">  up(&amp;wmutex);                  //release exit section</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.</p><p>From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">int readCount;                  // init to 0; number of readers currently accessing resource</span><br><span class="line"></span><br><span class="line">// all semaphores initialised to 1</span><br><span class="line">Semaphore resourceAccess;       // controls access (read/write) to the resource</span><br><span class="line">Semaphore readCountAccess;      // for syncing changes to shared variable readCount</span><br><span class="line">Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)</span><br><span class="line"></span><br><span class="line">void writer()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           // wait in line to be servicexs</span><br><span class="line">    // &lt;ENTER&gt;</span><br><span class="line">    down(&amp;resourceAccess);         // request exclusive access to resource</span><br><span class="line">    // &lt;/ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           // let next in line be serviced</span><br><span class="line"></span><br><span class="line">    // &lt;WRITE&gt;</span><br><span class="line">    writeResource();            // writing is performed</span><br><span class="line">    // &lt;/WRITE&gt;</span><br><span class="line"></span><br><span class="line">    // &lt;EXIT&gt;</span><br><span class="line">    up(&amp;resourceAccess);         // release resource access for next reader/writer</span><br><span class="line">    // &lt;/EXIT&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reader()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           // wait in line to be serviced</span><br><span class="line">    down(&amp;readCountAccess);        // request exclusive access to readCount</span><br><span class="line">    // &lt;ENTER&gt;</span><br><span class="line">    if (readCount == 0)         // if there are no readers already reading:</span><br><span class="line">        down(&amp;resourceAccess);     // request resource access for readers (writers blocked)</span><br><span class="line">    readCount++;                // update count of active readers</span><br><span class="line">    // &lt;/ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           // let next in line be serviced</span><br><span class="line">    up(&amp;readCountAccess);        // release access to readCount</span><br><span class="line"></span><br><span class="line">    // &lt;READ&gt;</span><br><span class="line">    readResource();             // reading is performed</span><br><span class="line">    // &lt;/READ&gt;</span><br><span class="line"></span><br><span class="line">    down(&amp;readCountAccess);        // request exclusive access to readCount</span><br><span class="line">    // &lt;EXIT&gt;</span><br><span class="line">    readCount--;                // update count of active readers</span><br><span class="line">    if (readCount == 0)         // if there are no readers left:</span><br><span class="line">        up(&amp;resourceAccess);     // release resource access for all</span><br><span class="line">    // &lt;/EXIT&gt;</span><br><span class="line">    up(&amp;readCountAccess);        // release access to readCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-哲学家进餐问题"><a href="#2-哲学家进餐问题" class="headerlink" title="2. 哲学家进餐问题"></a>2. 哲学家进餐问题</h3><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat();</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    test(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    test(LEFT);</span><br><span class="line">    test(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(i)</span> </span>&#123;         <span class="comment">// 尝试拿起两把筷子</span></span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>它具有以下限制：</p><ul><li>只支持半双工通信（单向交替传输）；</li><li>只能在父子进程中使用。</li></ul><h3 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2. FIFO"></a>2. FIFO</h3><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p><h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h3><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h3><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h3 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5. 共享存储"></a>5. 共享存储</h3><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。</p><h3 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h1 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h1><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h2 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h2><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h2 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h2><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><h3 id="1-每种类型一个资源的死锁检测"><a href="#1-每种类型一个资源的死锁检测" class="headerlink" title="1. 每种类型一个资源的死锁检测"></a>1. 每种类型一个资源的死锁检测</h3><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><h3 id="2-每种类型多个资源的死锁检测"><a href="#2-每种类型多个资源的死锁检测" class="headerlink" title="2. 每种类型多个资源的死锁检测"></a>2. 每种类型多个资源的死锁检测</h3><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><h3 id="3-死锁恢复"><a href="#3-死锁恢复" class="headerlink" title="3. 死锁恢复"></a>3. 死锁恢复</h3><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>在程序运行之前预防发生死锁。</p><h3 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h3><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><h3 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h3><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><h3 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h3><h3 id="4-破坏环路等待"><a href="#4-破坏环路等待" class="headerlink" title="4. 破坏环路等待"></a>4. 破坏环路等待</h3><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>在程序运行时避免发生死锁。</p><h3 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1. 安全状态"></a>1. 安全状态</h3><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><h3 id="2-单个资源的银行家算法"><a href="#2-单个资源的银行家算法" class="headerlink" title="2. 单个资源的银行家算法"></a>2. 单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h3 id="3-多个资源的银行家算法"><a href="#3-多个资源的银行家算法" class="headerlink" title="3. 多个资源的银行家算法"></a>3. 多个资源的银行家算法</h3><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h3 id="1-最佳"><a href="#1-最佳" class="headerlink" title="1. 最佳"></a>1. 最佳</h3><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><blockquote></blockquote><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h3 id="2-最近最久未使用"><a href="#2-最近最久未使用" class="headerlink" title="2. 最近最久未使用"></a>2. 最近最久未使用</h3><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><h3 id="3-最近未使用"><a href="#3-最近未使用" class="headerlink" title="3. 最近未使用"></a>3. 最近未使用</h3><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h3 id="4-先进先出"><a href="#4-先进先出" class="headerlink" title="4. 先进先出"></a>4. 先进先出</h3><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p><h3 id="5-第二次机会算法"><a href="#5-第二次机会算法" class="headerlink" title="5. 第二次机会算法"></a>5. 第二次机会算法</h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><h3 id="6-时钟"><a href="#6-时钟" class="headerlink" title="6. 时钟"></a>6. 时钟</h3><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h2 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h2><ul><li><p>对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。</p></li><li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p></li><li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p></li><li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p></li></ul><h1 id="五、设备管理"><a href="#五、设备管理" class="headerlink" title="五、设备管理"></a>五、设备管理</h1><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><ul><li>盘面（Platter）：一个磁盘有多个盘面；</li><li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li><li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li><li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li><li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li><li>主轴（Spindle）：使整个盘面转动。</li></ul><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h3 id="1-先来先服务"><a href="#1-先来先服务" class="headerlink" title="1. 先来先服务"></a>1. 先来先服务</h3><blockquote><p>FCFS, First Come First Served</p></blockquote><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h3 id="2-最短寻道时间优先"><a href="#2-最短寻道时间优先" class="headerlink" title="2. 最短寻道时间优先"></a>2. 最短寻道时间优先</h3><blockquote><p>SSTF, Shortest Seek Time First</p></blockquote><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p><h3 id="3-电梯算法"><a href="#3-电梯算法" class="headerlink" title="3. 电梯算法"></a>3. 电梯算法</h3><blockquote><p>SCAN</p></blockquote><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><h1 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h1><h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>以下是一个 hello.c 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure><p>这个过程大致如下：</p><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定向目标文件；</li><li>链接阶段：将可重定向目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定向目标文件：可与其它可重定向目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定向目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><h1 id="七、-常见面试题"><a href="#七、-常见面试题" class="headerlink" title="七、 常见面试题"></a>七、 常见面试题</h1><p><a href="https://zhuanlan.zhihu.com/p/23755202" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文参考自&lt;/a&gt;&lt;br&gt;&lt;!-- GFM-TOC --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一概述&quot;&gt;一、概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基本特征&quot;&gt;基本特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#基本功能&quot;&gt;基本功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#系统调用&quot;&gt;系统调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#大内核和微内核&quot;&gt;大内核和微内核&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#中断分类&quot;&gt;中断分类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二进程管理&quot;&gt;二、进程管理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#进程与线程&quot;&gt;进程与线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#进程状态的切换&quot;&gt;进程状态的切换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#进程调度算法&quot;&gt;进程调度算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#进程同步&quot;&gt;进程同步&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#经典同步问题&quot;&gt;经典同步问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#进程通信&quot;&gt;进程通信&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三死锁&quot;&gt;三、死锁&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#必要条件&quot;&gt;必要条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#处理方法&quot;&gt;处理方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#鸵鸟策略&quot;&gt;鸵鸟策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#死锁检测与死锁恢复&quot;&gt;死锁检测与死锁恢复&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#死锁预防&quot;&gt;死锁预防&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#死锁避免&quot;&gt;死锁避免&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四内存管理&quot;&gt;四、内存管理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#虚拟内存&quot;&gt;虚拟内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#分页系统地址映射&quot;&gt;分页系统地址映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#页面置换算法&quot;&gt;页面置换算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#分段&quot;&gt;分段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#段页式&quot;&gt;段页式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#分页与分段的比较&quot;&gt;分页与分段的比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#五设备管理&quot;&gt;五、设备管理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#磁盘结构&quot;&gt;磁盘结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#磁盘调度算法&quot;&gt;磁盘调度算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#六链接&quot;&gt;六、链接&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#编译系统&quot;&gt;编译系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#静态链接&quot;&gt;静态链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#目标文件&quot;&gt;目标文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#动态链接&quot;&gt;动态链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#常见面试题&quot;&gt;七、常见面试题&lt;/a&gt;&lt;!-- GFM-TOC --&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机操作系统" scheme="https://soleslie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://soleslie.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java中的内存溢出与泄漏</title>
    <link href="https://soleslie.github.io/2018/11/23/JVM/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%B3%84%E6%BC%8F/"/>
    <id>https://soleslie.github.io/2018/11/23/JVM/Java中的内存溢出与泄漏/</id>
    <published>2018-11-23T02:46:05.000Z</published>
    <updated>2018-11-23T03:01:46.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>内存泄漏指你用malloc或new申请了一块内存，但是没有通过free或delete将内存释放，导致这块内存一直处于占用状态。</p><p>内存溢出指你申请了10个字节的空间，但是你在这个空间写入11或以上字节的数据，就是溢出。内存溢出即用户在对其数据缓冲区操作时，超过了其缓冲区的边界；尤其是对缓冲区写操作时，缓冲区的溢出很可能导致程序的异常。</p><p>内存泄露是指程序中间动态分配了内存，但在程序结束时没有释放这部分内存，从而造成那部分内存不可用的情况，重启计算机可以解决，但也有可能再次发生内存泄露，内存泄露和硬件没有关系，它是由软件设计缺陷引起的。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>Java内存泄露与溢出的区别</p><p>内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。</p><p>Java内存泄漏就是没有及时清理内存垃圾，导致系统无法再给你提供内存资源（内存资源耗尽）。</p><p>看到上面的解释，可能有些朋友还是不太理解吧。没问题，看以下例子:</p><p>1.Java内存泄露是说程序逻辑问题,造成申请的内存无法释放.这样的话无论多少内存,早晚都会被占用光的.<br>最简单的例子就是死循环了.由于程序判断错误导经常发生此事。</p><p>2.Java内存泄漏是指在堆上分配的内存没有被释放，从而失去对其控制。这样会造成程序能使用的内存越来越少，导致系统运行速度减慢，严重情况会使程序当掉。</p><p>3.关于内存溢出有点出入。比如说你申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p><p>举个现实中的例子：<br>比如有一个桶，装满了水.你丢个苹果进去。桶的水正常。如果你放个大石头。水就出溢出，内存溢出也就是这个原理。<br>区别：内存溢出，提供的内存不够；Java内存泄漏，无法再提供内存资源。</p><h1 id="详解java中的内存泄漏"><a href="#详解java中的内存泄漏" class="headerlink" title="详解java中的内存泄漏"></a>详解java中的内存泄漏</h1><h2 id="1-Java内存回收机制"><a href="#1-Java内存回收机制" class="headerlink" title="1. Java内存回收机制"></a>1. Java内存回收机制</h2><p>不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。</p><h2 id="2-Java内存泄漏引起的原因"><a href="#2-Java内存泄漏引起的原因" class="headerlink" title="2. Java内存泄漏引起的原因"></a>2. Java内存泄漏引起的原因</h2><p>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。</p><p>Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：</p><h3 id="1-静态集合类引起内存泄漏："><a href="#1-静态集合类引起内存泄漏：" class="headerlink" title="1. 静态集合类引起内存泄漏："></a>1. 静态集合类引起内存泄漏：</h3><p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Static Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">v.add(o);</span><br><span class="line">o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</p><h3 id="2-当集合里面的对象属性被修改后，再调用remove-方法时不起作用。"><a href="#2-当集合里面的对象属性被修改后，再调用remove-方法时不起作用。" class="headerlink" title="2. 当集合里面的对象属性被修改后，再调用remove()方法时不起作用。"></a>2. 当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"唐僧"</span>,<span class="string">"pwd1"</span>,<span class="number">25</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>,<span class="string">"pwd2"</span>,<span class="number">26</span>);</span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>,<span class="string">"pwd3"</span>,<span class="number">27</span>);</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:3 个元素!</span></span><br><span class="line">p3.setAge(<span class="number">2</span>); <span class="comment">//修改p3的年龄,此时p3元素对应的hashcode值发生改变</span></span><br><span class="line">set.remove(p3); <span class="comment">//此时remove不掉，造成内存泄漏</span></span><br><span class="line">set.add(p3); <span class="comment">//重新添加，居然添加成功</span></span><br><span class="line">System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:4 个元素!</span></span><br><span class="line"><span class="keyword">for</span> (Person person : set)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3.监听器"></a>3.监听器</h3><p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p><h3 id="4-各种连接"><a href="#4-各种连接" class="headerlink" title="4.各种连接"></a>4.各种连接</h3><p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。</p><h3 id="5-内部类和外部模块的引用"><a href="#5-内部类和外部模块的引用" class="headerlink" title="5.内部类和外部模块的引用"></a>5.内部类和外部模块的引用</h3><p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：</p><p>public void registerMsg(Object b);</p><p>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p><h3 id="6-单例模式"><a href="#6-单例模式" class="headerlink" title="6. 单例模式"></a>6. 单例模式</h3><p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">B.getInstance().setA(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B类采用单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> A a;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> B instance=<span class="keyword">new</span> B();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getter...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;内存泄漏指你用malloc或new申请了一块内存，但是没有通过free或delete将内存释放，导致这块内存一直处于占用状态。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="JVM" scheme="https://soleslie.github.io/categories/JVM/"/>
    
    
      <category term="JVM,内存溢出与泄漏" scheme="https://soleslie.github.io/tags/JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java集合详解4——HashMap和HashTable</title>
    <link href="https://soleslie.github.io/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A34-HashMap%E5%92%8CHashTable/"/>
    <id>https://soleslie.github.io/2018/11/21/Java集合详解/java集合详解4-HashMap和HashTable/</id>
    <published>2018-11-21T08:54:47.000Z</published>
    <updated>2018-11-28T02:20:37.084Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://h2pl.github.io/2018/05/10/collection4/" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/10/collection4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java集合详解" scheme="https://soleslie.github.io/categories/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="Java集合" scheme="https://soleslie.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解3——Iterator,fail-fast机制与比较器</title>
    <link href="https://soleslie.github.io/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A33-Iterator/"/>
    <id>https://soleslie.github.io/2018/11/21/Java集合详解/Java集合详解3-Iterator/</id>
    <published>2018-11-21T08:30:44.000Z</published>
    <updated>2018-11-21T08:48:25.078Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://h2pl.github.io/2018/05/09/collection3/" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/05/09/collection3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java集合详解" scheme="https://soleslie.github.io/categories/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="Java集合" scheme="https://soleslie.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解2——LinkedList,Queue</title>
    <link href="https://soleslie.github.io/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A32-LinkedList-Queue/"/>
    <id>https://soleslie.github.io/2018/11/21/Java集合详解/Java集合详解2-LinkedList-Queue/</id>
    <published>2018-11-21T07:53:41.000Z</published>
    <updated>2018-11-21T08:45:01.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList概述</p><p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。<br><a id="more"></a><br>LinkedList实现所有可选的列表操作，并允许所有的元素包括null。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 、和insert元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p><p>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。</p><p>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。</p><p>同时，与ArrayList一样此实现不是同步的。</p><p>（以上摘自JDK 6.0 API）。</p><p>源码分析</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>首先我们先看LinkedList的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">      从这段代码中我们可以清晰地看出<span class="title">LinkedList</span>继承<span class="title">AbstractSequentialList</span>，实现<span class="title">List</span>、<span class="title">Deque</span>、<span class="title">Cloneable</span>、<span class="title">Serializable</span>。其中<span class="title">AbstractSequentialList</span>提供了 <span class="title">List</span> 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现<span class="title">List</span>接口的复杂度。<span class="title">Deque</span>一个线性 <span class="title">collection</span>，支持在两端插入和移除元素，定义了双端队列的操作。</span></span><br></pre></td></tr></table></figure></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在LinkedList中提供了两个基本属性size、header</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry header = <span class="keyword">new</span> Entry(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E element;        <span class="comment">//元素节点</span></span><br><span class="line">    Entry&lt;E&gt; next;    <span class="comment">//下一个元素</span></span><br><span class="line">    Entry&lt;E&gt; previous;  <span class="comment">//上一个元素</span></span><br><span class="line"></span><br><span class="line">    Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.previous = previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>LinkedList提供了两个构造方法：LinkedList()和LinkedList(Collection&lt;? extends E&gt; c)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构造一个空列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        header.next = header.previous = header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>LinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。</p><p>LinkedList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;    <span class="comment">//插入元素的个数</span></span><br><span class="line">    <span class="comment">//若插入的元素为空，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//modCount:在AbstractList中定义的，表示从结构上修改列表的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点</span></span><br><span class="line">    Entry&lt;E&gt; successor = (index == size ? header : entry(index));</span><br><span class="line">    <span class="comment">//插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素</span></span><br><span class="line">    Entry&lt;E&gt; predecessor = successor.previous;</span><br><span class="line">    <span class="comment">//执行插入动作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numNew; i++) &#123;</span><br><span class="line">        <span class="comment">//构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Entry&lt;E&gt; e = <span class="keyword">new</span> Entry&lt;E&gt;((E) a[i], successor, predecessor);</span><br><span class="line">        <span class="comment">//将插入位置前一个节点的下一个元素引用指向当前元素</span></span><br><span class="line">        predecessor.next = e;</span><br><span class="line">        <span class="comment">//修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序</span></span><br><span class="line">        predecessor = e;</span><br><span class="line">    &#125;</span><br><span class="line">    successor.previous = predecessor;</span><br><span class="line">    <span class="comment">//修改容量大小</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">  在addAll()方法中，涉及到了两个方法，一个是entry(<span class="keyword">int</span> index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定位置(若存在)的节点元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">entry</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + index + <span class="string">", Size: "</span></span><br><span class="line">                    + size);</span><br><span class="line">        <span class="comment">//头部节点</span></span><br><span class="line">        Entry&lt;E&gt; e = header;</span><br><span class="line">        <span class="comment">//判断遍历的方向</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++)</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--)</span><br><span class="line">                e = e.previous;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。</p><p>由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。</p><h2 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h2><p>  add(E e): 将指定元素添加到此列表的结尾。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addBefore(e, header);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      该方法调用addBefore方法，然后直接返回<span class="keyword">true</span>，对于addBefore()而已，它为LinkedList的私有方法。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">addBefore</span><span class="params">(E e, Entry&lt;E&gt; entry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//利用Entry构造函数构建一个新节点 newEntry，</span></span><br><span class="line">        Entry&lt;E&gt; newEntry = <span class="keyword">new</span> Entry&lt;E&gt;(e, entry, entry.previous);</span><br><span class="line">        <span class="comment">//修改newEntry的前后节点的引用，确保其链表的引用关系是正确的</span></span><br><span class="line">        newEntry.previous.next = newEntry;</span><br><span class="line">        newEntry.next.previous = newEntry;</span><br><span class="line">        <span class="comment">//容量+1</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//修改次数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> newEntry;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。</p><p>LinkedList还提供了其他的增加方法：</p><p>add(int index, E element)：在此列表中指定的位置插入指定的元素。</p><p>addAll(Collection&lt;? extends E&gt; c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。</p><p>addAll(int index, Collection&lt;? extends E&gt; c)：将指定 collection 中的所有元素从指定位置开始插入此列表。</p><p>AddFirst(E e): 将指定元素插入此列表的开头。</p><p>addLast(E e): 将指定元素添加到此列表的结尾。</p><h2 id="移除方法"><a href="#移除方法" class="headerlink" title="移除方法"></a>移除方法</h2><p>  remove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.element==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    remove(e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(e.element)) &#123;</span><br><span class="line">                    remove(e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">该方法首先会判断移除的元素是否为<span class="keyword">null</span>，然后迭代这个链表找到该元素节点，最后调用remove(Entry e)，remove(Entry e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">remove</span><span class="params">(Entry&lt;E&gt; e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == header)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保留被移除的元素：要返回</span></span><br><span class="line">        E result = e.element;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将该节点的前一节点的next指向该节点后节点</span></span><br><span class="line">        e.previous.next = e.next;</span><br><span class="line">        <span class="comment">//将该节点的后一节点的previous指向该节点的前节点</span></span><br><span class="line">        <span class="comment">//这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的</span></span><br><span class="line">        e.next.previous = e.previous;</span><br><span class="line">        <span class="comment">//将该节点归空</span></span><br><span class="line">        e.next = e.previous = <span class="keyword">null</span>;</span><br><span class="line">        e.element = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的移除方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">clear()： 从此列表中移除所有元素。</span><br><span class="line"></span><br><span class="line">remove()：获取并移除此列表的头（第一个元素）。</span><br><span class="line"></span><br><span class="line">remove(<span class="keyword">int</span> index)：移除此列表中指定位置处的元素。</span><br><span class="line"></span><br><span class="line">remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。</span><br><span class="line"></span><br><span class="line">removeFirst()：移除并返回此列表的第一个元素。</span><br><span class="line"></span><br><span class="line">removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。</span><br><span class="line"></span><br><span class="line">removeLast()：移除并返回此列表的最后一个元素。</span><br><span class="line"></span><br><span class="line">removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。</span><br></pre></td></tr></table></figure><h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><p>对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="keyword">int</span> index)：返回此列表中指定位置处的元素。</span><br><span class="line"></span><br><span class="line">getFirst()：返回此列表的第一个元素。</span><br><span class="line"></span><br><span class="line">getLast()：返回此列表的最后一个元素。</span><br><span class="line"></span><br><span class="line">indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue接口定义了队列数据结构，元素是有序的(按插入顺序)，先进先出。</p><h2 id="DeQueue"><a href="#DeQueue" class="headerlink" title="DeQueue"></a>DeQueue</h2><p>DeQueue(Double-ended queue)为接口，继承了Queue接口，创建双向队列，灵活性更强，可以前向或后向迭代，在队头队尾均可心插入或删除元素。它的两个主要实现类是ArrayDeque和LinkedList。</p><h2 id="ArrayDeque-（底层使用循环数组实现双向队列）"><a href="#ArrayDeque-（底层使用循环数组实现双向队列）" class="headerlink" title="ArrayDeque （底层使用循环数组实现双向队列）"></a>ArrayDeque （底层使用循环数组实现双向队列）</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 默认容量为16</span></span><br><span class="line">   elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 指定容量的构造函数</span></span><br><span class="line">   allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;<span class="comment">// 最小容量为8</span></span><br><span class="line">        <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">        <span class="comment">// Tests "&lt;=" because arrays aren't kept full.</span></span><br><span class="line">        <span class="comment">// 如果要分配的容量大于等于8，扩大成2的幂（是为了维护头、尾下标值）；否则使用最小容量8</span></span><br><span class="line">        <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            initialCapacity++;</span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">                initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">        &#125;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="add操作"><a href="#add操作" class="headerlink" title="add操作"></a>add操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">add(E e) 调用 addLast(E e) 方法：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"e == null"</span>);</span><br><span class="line">   elements[tail] = e; <span class="comment">// 根据尾索引，添加到尾端</span></span><br><span class="line">   <span class="comment">// 尾索引+1，并与数组（length - 1）进行取‘&amp;’运算，因为length是2的幂，所以（length-1）转换为2进制全是1，</span></span><br><span class="line">   <span class="comment">// 所以如果尾索引值 tail 小于等于（length - 1），那么‘&amp;’运算后仍为 tail 本身；如果刚好比（length - 1）大1时，</span></span><br><span class="line">   <span class="comment">// ‘&amp;’运算后 tail 便为0（即回到了数组初始位置）。正是通过与（length - 1）进行取‘&amp;’运算来实现数组的双向循环。</span></span><br><span class="line">   <span class="comment">// 如果尾索引和头索引重合了，说明数组满了，进行扩容。</span></span><br><span class="line">   <span class="keyword">if</span> ((tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">      doubleCapacity();<span class="comment">// 扩容为原来的2倍</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addFirst(E e) 的实现：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"e == null"</span>);</span><br><span class="line">   <span class="comment">// 此处如果head为0，则-1（1111 1111 1111 1111 1111 1111 1111 1111）与（length - 1）进行取‘&amp;’运算，结果必然是（length - 1），即回到了数组的尾部。</span></span><br><span class="line">   elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">   <span class="comment">// 如果尾索引和头索引重合了，说明数组满了，进行扩容</span></span><br><span class="line">   <span class="keyword">if</span> (head == tail)</span><br><span class="line">      doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">remove()方法最终都会调对应的poll()方法：</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = head;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E result = (E) elements[h];</span><br><span class="line">        <span class="comment">// Element is null if deque empty</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">        <span class="comment">// 头索引 + 1</span></span><br><span class="line">        head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尾索引 - 1</span></span><br><span class="line">        <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E result = (E) elements[t];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[t] = <span class="keyword">null</span>;</span><br><span class="line">        tail = t;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="PriorityQueue（底层用数组实现堆的结构）"><a href="#PriorityQueue（底层用数组实现堆的结构）" class="headerlink" title="PriorityQueue（底层用数组实现堆的结构）"></a>PriorityQueue（底层用数组实现堆的结构）</h2><p>优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。 而优先队列每次拿数据的时候都会拿出优先级最高的数据。</p><p>优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据（堆顶的优先级最高），这就是优先队列的原理。</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e); <span class="comment">// add方法内部调用offer方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="comment">// 元素为空的话，抛出NullPointerException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length) <span class="comment">// 如果当前用堆表示的数组已经满了，调用grow方法扩容</span></span><br><span class="line">        grow(i + <span class="number">1</span>); <span class="comment">// 扩容</span></span><br><span class="line">    size = i + <span class="number">1</span>; <span class="comment">// 元素个数+1</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="comment">// 堆还没有元素的情况</span></span><br><span class="line">        queue[<span class="number">0</span>] = e; <span class="comment">// 直接给堆顶赋值元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 堆中已有元素的情况</span></span><br><span class="line">        siftUp(i, e); <span class="comment">// 重新调整堆，从下往上调整，因为新增元素是加到最后一个叶子节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)  <span class="comment">// 比较器存在的情况下</span></span><br><span class="line">        siftUpUsingComparator(k, x); <span class="comment">// 使用比较器调整</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 比较器不存在的情况下</span></span><br><span class="line">        siftUpComparable(k, x); <span class="comment">// 使用元素自身的比较器调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123; <span class="comment">// 一直循环直到父节点还存在</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 找到父节点索引，等同于（k - 1）/ 2</span></span><br><span class="line">        Object e = queue[parent]; <span class="comment">// 获得父节点元素</span></span><br><span class="line">        <span class="comment">// 新元素与父元素进行比较，如果满足比较器结果，直接跳出，否则进行调整</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e; <span class="comment">// 进行调整，新位置的元素变成了父元素</span></span><br><span class="line">        k = parent; <span class="comment">// 新位置索引变成父元素索引，进行递归操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x; <span class="comment">// 新添加的元素添加到堆中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll，出队方法"><a href="#poll，出队方法" class="headerlink" title="poll，出队方法"></a>poll，出队方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size; <span class="comment">// 元素个数-1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>]; <span class="comment">// 得到堆顶元素</span></span><br><span class="line">    E x = (E) queue[s]; <span class="comment">// 最后一个叶子节点</span></span><br><span class="line">    queue[s] = <span class="keyword">null</span>; <span class="comment">// 最后1个叶子节点置空</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x); <span class="comment">// 从上往下调整，因为删除元素是删除堆顶的元素</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) <span class="comment">// 比较器存在的情况下</span></span><br><span class="line">        siftDownUsingComparator(k, x); <span class="comment">// 使用比较器调整</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 比较器不存在的情况下</span></span><br><span class="line">        siftDownComparable(k, x); <span class="comment">// 使用元素自身的比较器调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 只需循环节点个数的一般即可</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 得到父节点的左子节点索引，即（k * 2）+ 1</span></span><br><span class="line">        Object c = queue[child]; <span class="comment">// 得到左子元素</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>; <span class="comment">// 得到父节点的右子节点索引</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>) <span class="comment">// 左子节点跟右子节点比较，取更大的值</span></span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)  <span class="comment">// 然后这个更大的值跟最后一个叶子节点比较</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c; <span class="comment">// 新位置使用更大的值</span></span><br><span class="line">        k = child; <span class="comment">// 新位置索引变成子元素索引，进行递归操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x; <span class="comment">// 最后一个叶子节点添加到合适的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove，删除队列元素"><a href="#remove，删除队列元素" class="headerlink" title="remove，删除队列元素"></a>remove，删除队列元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o); <span class="comment">// 找到数据对应的索引</span></span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>) <span class="comment">// 不存在的话返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 存在的话调用removeAt方法，返回true</span></span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size; <span class="comment">// 元素个数-1</span></span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// 如果是删除最后一个叶子节点</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>; <span class="comment">// 直接置空，删除即可，堆还是保持特质，不需要调整</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 如果是删除的不是最后一个叶子节点</span></span><br><span class="line">        E moved = (E) queue[s]; <span class="comment">// 获得最后1个叶子节点元素</span></span><br><span class="line">        queue[s] = <span class="keyword">null</span>; <span class="comment">// 最后1个叶子节点置空</span></span><br><span class="line">        siftDown(i, moved); <span class="comment">// 从上往下调整</span></span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123; <span class="comment">// 如果从上往下调整完毕之后发现元素位置没变，从下往上调整</span></span><br><span class="line">            siftUp(i, moved); <span class="comment">// 从下往上调整</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行 siftDown() 下滤过程：</p><p>(<a href="https://upload-images.jianshu.io/upload_images/195193-a64dbb5508a9c668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/195193-a64dbb5508a9c668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642</a>)</p><p>再执行 siftUp() 上滤过程：<br>(<a href="https://upload-images.jianshu.io/upload_images/195193-e9ad437213e69b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/195193-e9ad437213e69b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633</a>)</p><h2 id="总结和同步的问题"><a href="#总结和同步的问题" class="headerlink" title="总结和同步的问题"></a>总结和同步的问题</h2><p>1、jdk内置的优先队列PriorityQueue内部使用一个堆维护数据，每当有数据add进来或者poll出去的时候会对堆做从下往上的调整和从上往下的调整。</p><p>2、PriorityQueue不是一个线程安全的类，如果要在多线程环境下使用，可以使用 PriorityBlockingQueue 这个优先阻塞队列。其中add、poll、remove方法都使用 ReentrantLock 锁来保持同步，take() 方法中如果元素为空，则会一直保持阻塞</p><p>本文转载自：<a href="https://h2pl.github.io/2018/05/09/collection2/" target="_blank" rel="noopener">h2pl</a> <a href="https://h2pl.github.io/2018/05/09/collection2/" target="_blank" rel="noopener">https://h2pl.github.io/2018/05/09/collection2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LinkedList&quot;&gt;&lt;a href=&quot;#LinkedList&quot; class=&quot;headerlink&quot; title=&quot;LinkedList&quot;&gt;&lt;/a&gt;LinkedList&lt;/h1&gt;&lt;p&gt;LinkedList概述&lt;/p&gt;
&lt;p&gt;LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。&lt;br&gt;
    
    </summary>
    
      <category term="Java集合详解" scheme="https://soleslie.github.io/categories/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="Java集合" scheme="https://soleslie.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合详解1——ArrayList,Vector,Stack</title>
    <link href="https://soleslie.github.io/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A31-ArrayList-Vector-Stack/"/>
    <id>https://soleslie.github.io/2018/11/21/Java集合详解/Java集合详解1-ArrayList-Vector-Stack/</id>
    <published>2018-11-21T07:05:57.000Z</published>
    <updated>2018-11-21T08:48:19.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h1><h2 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h2><p>ArrayList是实现List接口的动态数组，所谓动态就是它的大小是可变的。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。<br><a id="more"></a></p><p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。默认初始容量为10。随着ArrayList中元素的增加，它的容量也会不断的自动增长。</p><p>在每次添加新的元素时，ArrayList都会检查是否需要进行扩容操作，扩容操作带来数据向新数组的重新拷贝，所以如果我们知道具体业务数据量，在构造ArrayList时可以给ArrayList指定一个初始容量，这样就会减少扩容时数据的拷贝问题。当然在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p><p>注意，ArrayList实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。所以为了保证同步，最好的办法是在创建时完成，以防止意外对列表进行不同步的访问：</p><p>List list = Collections.synchronizedList(new ArrayList(…)); </p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>ArrayList的底层是一个object数组，并且由trasient修饰。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"></span><br><span class="line">non-<span class="keyword">private</span> to simplify nested <span class="class"><span class="keyword">class</span> <span class="title">access</span></span></span><br><span class="line"><span class="class"><span class="title">ArrayList</span>底层数组不会参与序列化，而是使用另外的序列化方式。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">使用<span class="title">writeobject</span>方法进行序列化,具体为什么这么做欢迎查看我之前的关于序列化的文章</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">总结一下就是只复制数组中有值的位置，其他未赋值的位置不进行序列化，可以节省空间。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">void</span> <span class="title">writeObject</span>(<span class="title">java</span>.<span class="title">io</span>.<span class="title">ObjectOutputStream</span> <span class="title">s</span>)</span></span><br><span class="line"><span class="class">        <span class="title">throws</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">IOException</span> </span>&#123;</span><br><span class="line">         Write out element count, and any hidden stuff</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         s.defaultWriteObject();</span><br><span class="line">         Write out size as capacity <span class="keyword">for</span> behavioural compatibility with clone</span><br><span class="line">            s.writeInt(size);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                s.writeObject(elementData[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>添加元素时，首先判断索引是否合法，然后检测是否需要扩容，最后使用System.arraycopy方法来完成数组的复制。</p><p>这个方法无非就是使用System.arraycopy()方法将C集合(先准换为数组)里面的数据复制到elementData数组中。这里就稍微介绍下System.arraycopy()，因为下面还将大量用到该方法。该方法的原型为：</p><p>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)。</p><p>它的根本目的就是进行数组元素的复制。即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p><p>将源数组src从srcPos位置开始复制到dest数组中，复制长度为length，数据从dest的destPos位置开始粘贴。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);   Increments modCount!!</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">    &#125;</span><br><span class="line">删除元素时，同样判断索引是否和法，删除的方式是把被删除元素右边的元素左移，方法同样是使用System.arraycopy进行拷贝。</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;  clear to let GC <span class="keyword">do</span> its work</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ArrayList提供一个清空数组的办法，方法是将所有元素置为null，这样就可以让GC自动回收掉没有被引用的元素了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment">    * be empty after this call returns.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">     clear to let GC <span class="keyword">do</span> its work</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>修改元素时，只需要检查下标即可进行修改操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;            </span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述方法都使用了rangeCheck方法，其实就是简单地检查下标而已。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>由以上代码可以看出，在一个迭代器初始的时候会赋予它调用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存储的mcount不一样那就抛异常，也就是Fail-Fast 机制，我们知道 java.util.ArrayList 不是线程安全的，ArrayList，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对ArrayList内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了ArrayList，<strong>所以在这里和大家建议，当大家遍历那些非线程安全的数据结构时，尽量使用迭代器。</strong></p><h2 id="初始容量和扩容方式"><a href="#初始容量和扩容方式" class="headerlink" title="初始容量和扩容方式"></a>初始容量和扩容方式</h2><p>初始容量是10，下面是扩容方法。<br>首先先取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>扩容发生在add元素时，传入当前元素容量加一<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);   Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里给出初始化时的数组<br>    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</p><p>这说明：如果数组还是初始数组，那么最小的扩容大小就是size+1和初始容量中较大的一个，初始容量为10。<br>因为addall方法也会调用该函数，所以此时需要做判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">开始精确地扩容</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">     overflow-conscious code</span><br><span class="line">    如果此时扩容容量大于数组长度吗，执行grow，否则不执行。</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真正执行扩容的方法grow,扩容方式是让新容量等于旧容量的1.5倍。当新容量大于最大数组容量时，执行大数扩容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     overflow-conscious code</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">         minCapacity is usually close to size, so <span class="keyword">this</span> is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当新容量大于最大数组长度，有两种情况，一种是溢出，抛异常，一种是没溢出，返回整数的最大值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)  overflow</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里有一个疑问，为什么每次扩容处理会是1.5倍，而不是2.5、3、4倍呢？通过google查找，发现1.5倍的扩容是最好的倍数。因为一次性扩容太大(例如2.5倍)可能会浪费更多的内存(1.5倍最多浪费33%，而2.5被最多会浪费60%，3.5倍则会浪费71%……)。但是一次性扩容太小，需要多次对数组重新分配内存，对性能消耗比较严重。所以1.5倍刚刚好，既能满足性能需求，也不会造成很大的内存消耗。</p><p>处理这个ensureCapacity()这个扩容数组外，ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize()方法来实现。该方法可以最小化ArrayList实例的存储量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; oldCapacity) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>ArrayList是线程不安全的。在其迭代器iteator中，如果有多线程操作导致modcount改变，会执行fast-fail,抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector简介</p><p>Vector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。</p><p>Vector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍历等功能。</p><p>Vector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。</p><p>Vector 实现了Cloneable接口，支持clone()方法，可以被克隆。</p><p>vector底层数组不加transient，序列化时会全部复制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br><span class="line">    <span class="keyword">final</span> Object[] data;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        fields.put(<span class="string">"capacityIncrement"</span>, capacityIncrement);</span><br><span class="line">        fields.put(<span class="string">"elementCount"</span>, elementCount);</span><br><span class="line">        data = elementData.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    fields.put(<span class="string">"elementData"</span>, data);</span><br><span class="line">    s.writeFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h2><p>vector的增删改查既提供了自己的实现，也继承了abstractList抽象类的部分方法。<br>下面的方法是vector自己实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">            elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">            elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount--;</span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">        + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line"> &#125;</span><br><span class="line"> ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line"> System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line"> elementData[index] = obj;</span><br><span class="line"> elementCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始容量和扩容"><a href="#初始容量和扩容" class="headerlink" title="初始容量和扩容"></a>初始容量和扩容</h2><p>扩容方式与ArrayList基本一样，但是扩容时不是1.5倍扩容，而是有一个扩容增量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>capacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   overflow-conscious code</span><br><span class="line">   <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   overflow-conscious code</span><br><span class="line">   <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">   <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">    capacityIncrement : oldCapacity);</span><br><span class="line">   <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h2><p>vector大部分方法都使用了synchronized修饰符，所以他是线层安全的集合类。</p><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出。</p><p>Stack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">empty()</span><br><span class="line"></span><br><span class="line">测试堆栈是否为空。</span><br><span class="line"></span><br><span class="line">peek()</span><br><span class="line"></span><br><span class="line">查看堆栈顶部的对象，但不从堆栈中移除它。</span><br><span class="line"></span><br><span class="line">pop()</span><br><span class="line"></span><br><span class="line">移除堆栈顶部的对象，并作为此函数的值返回该对象。</span><br><span class="line"></span><br><span class="line">push(E item)</span><br><span class="line"></span><br><span class="line">把项压入堆栈顶部。</span><br><span class="line"></span><br><span class="line">search(Object o)</span><br><span class="line"></span><br><span class="line">返回对象在堆栈中的位置，以 <span class="number">1</span> 为基数。</span><br></pre></td></tr></table></figure></p><p>Stack继承Vector，他对Vector进行了简单的扩展：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> <span class="keyword">extends</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class"><span class="title">Stack</span>的实现非常简单，仅有一个构造方法，五个实现方法（从<span class="title">Vector</span>继承而来的方法不算与其中），同时其实现的源码非常简单</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * 构造函数</span></span><br><span class="line"><span class="class"> */</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Stack</span>() </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  push函数：将元素存入栈顶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">     将元素存入栈顶。</span><br><span class="line">     addElement()的实现在Vector.java中</span><br><span class="line">    addElement(item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pop函数：返回栈顶元素，并将其从栈中删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E    obj;</span><br><span class="line">    <span class="keyword">int</span>    len = size();</span><br><span class="line"></span><br><span class="line">    obj = peek();</span><br><span class="line">     删除栈顶元素，removeElementAt()的实现在Vector.java中</span><br><span class="line">    removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * peek函数：返回栈顶元素，不执行删除操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>    len = size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">     返回栈顶元素，elementAt()具体实现在Vector.java中</span><br><span class="line">    <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  查找“元素o”在栈中的位置：由栈底向栈顶方向数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     获取元素索引，elementAt()具体实现在Vector.java中</span><br><span class="line">    <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Stack的源码很多都是基于Vector，所以这里不再累述</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>ArrayList的优缺点</p><p>从上面的几个过程总结一下ArrayList的优缺点。ArrayList的优点如下：</p><ol><li>ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快</li><li><p>ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已<br>不过ArrayList的缺点也十分明显：</p></li><li><p>删除元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p></li><li><p>插入元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p></li></ol><p>因此，ArrayList比较适合顺序添加、随机访问的场景。</p><p>ArrayList和Vector的区别<br>ArrayList是线程非安全的，这很明显，因为ArrayList中所有的方法都不是同步的，在并发下一定会出现线程安全问题。那么我们想要使用ArrayList并且让它线程安全怎么办？一个方法是用Collections.synchronizedList方法把你的ArrayList变成一个线程安全的List，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">"aaa"</span>);</span><br><span class="line">synchronizedList.add(<span class="string">"bbb"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; synchronizedList.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法就是Vector，它是ArrayList的线程安全版本，其实现90%和ArrayList都完全一样，区别在于：</p><ol><li><p>Vector是线程安全的，ArrayList是线程非安全的</p></li><li><p>Vector可以指定增长因子，如果该增长因子指定了，那么扩容的时候会每次新的数组大小会在原数组的大小基础上加上增长因子；如果不指定增长因子，那么就给原数组大小*2，源代码是这样的：<br> int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</p><pre><code>capacityIncrement : oldCapacity);</code></pre></li></ol><p>本文转载出处：<a href="https://h2pl.github.io/2018/05/08/collection1/" target="_blank" rel="noopener">h2pl</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-ArrayList&quot;&gt;&lt;a href=&quot;#1-ArrayList&quot; class=&quot;headerlink&quot; title=&quot;1.ArrayList&quot;&gt;&lt;/a&gt;1.ArrayList&lt;/h1&gt;&lt;h2 id=&quot;ArrayList概述&quot;&gt;&lt;a href=&quot;#ArrayList概述&quot; class=&quot;headerlink&quot; title=&quot;ArrayList概述&quot;&gt;&lt;/a&gt;ArrayList概述&lt;/h2&gt;&lt;p&gt;ArrayList是实现List接口的动态数组，所谓动态就是它的大小是可变的。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。&lt;br&gt;
    
    </summary>
    
      <category term="Java集合详解" scheme="https://soleslie.github.io/categories/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="Java集合" scheme="https://soleslie.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>第四章——对象的组合</title>
    <link href="https://soleslie.github.io/2018/11/19/JavaConcurrencyinPractice/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/"/>
    <id>https://soleslie.github.io/2018/11/19/JavaConcurrencyinPractice/第四章——对象的组合/</id>
    <published>2018-11-19T05:36:20.000Z</published>
    <updated>2018-11-21T08:36:39.016Z</updated>
    
    <content type="html"><![CDATA[<p>本章将介绍一些组合模式，这些模式能够使一个类更容易成为线程安全的，并且在维护这些类时不会无意破坏类的安全性保证。<br><a id="more"></a></p><h1 id="4-1-设计线程安全的类"><a href="#4-1-设计线程安全的类" class="headerlink" title="4.1 设计线程安全的类"></a>4.1 设计线程安全的类</h1><p>通过使用线程封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否时线程安全的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在设计线程安全类的过程中，需要包含以下三个基本要素：</span><br><span class="line">1. 找出构成对象状态的所有变量</span><br><span class="line">2. 找出约束状态变量的不可变条件</span><br><span class="line">3. 建立对象状态的并发访问管理策略</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章将介绍一些组合模式，这些模式能够使一个类更容易成为线程安全的，并且在维护这些类时不会无意破坏类的安全性保证。&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程实战" scheme="https://soleslie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Java Concurrency in Practice" scheme="https://soleslie.github.io/tags/Java-Concurrency-in-Practice/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="https://soleslie.github.io/2018/11/19/%E5%89%91%E6%8C%87offer/"/>
    <id>https://soleslie.github.io/2018/11/19/剑指offer/</id>
    <published>2018-11-19T02:36:36.000Z</published>
    <updated>2018-11-28T12:59:22.307Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer的实现 参考文章<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md" target="_blank" rel="noopener">传送门</a><br><a id="more"></a><br><!-- GFM-TOC --></p><ul><li><a href="#1-数组中重复的数字">1. 数组中重复的数字</a></li><li><a href="#2-二维数组的查找">2. 二维数组中的查找</a></li><li><a href="#3-替换空格">3. 替换空格</a></li><li><a href="#4-从尾到头打印链表">4. 从尾到头打印链表</a></li><li><a href="#5-重建二叉树">5. 重建二叉树</a></li><li><a href="#6. 二叉树的下一个节点">6. 二叉树的下一个节点</a></li><li><a href="#7-用两个栈实现队列">7. 用两个栈实现队列</a></li><li><a href="#8-斐波那契数列">8. 斐波那契数列</a></li><li><a href="#9-跳台阶">9. 跳台阶</a></li><li><a href="#10-矩形覆盖">10. 矩形覆盖</a></li><li><a href="#11-变态跳台阶">11. 变态跳台阶</a></li><li><a href="#12-旋转数组的最小数字">12. 旋转数组的最小数字</a></li><li><a href="#13-矩阵中的路径">13. 矩阵中的路径</a></li><li><a href="#14-机器人的运动范围">14. 机器人的运动范围</a></li><li><a href="#15-剪绳子">15. 剪绳子</a></li><li><a href="#16-二进制数中1的个数">16. 二进制数中1的个数</a></li><li><a href="#17-数组的整数次方">17. 数组的整数次方</a></li><li><a href="#18-打印从1到最大的n位数">18. 打印从1到最大的n 位数</a></li><li><a href="#19-在O(1">19. 在O(1)时间内删除链表节点</a>时间内删除链表节点)</li><li><a href="#20-删除链表重复的节点">20. 删除链表重复的节点</a></li><li><a href="#21-正则表达式匹配">21. 正则表达式匹配</a></li><li><a href="#22-表示数值的字符串">22. 表示数值的字符串</a></li><li><a href="#23-调整数组顺序使奇数位于偶数前面">23. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="#24-链表中倒数第-k-个结点">24. 链表中倒数第 K 个结点</a></li><li><a href="#25-链表中环的入口结点">25. 链表中环的入口结点</a></li><li><a href="#26-反转链表">26. 反转链表</a></li><li><a href="#27-合并两个排序的链表">27. 合并两个排序的链表</a><!-- GFM-TOC --></li></ul><h1 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1.数组中重复的数字"></a>1.数组中重复的数字</h1><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;2, 3, 1, 0, 2, 5&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求复杂度为 O(N) + O(1)，也就是时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。牛客网讨论区这一题的首票答案使用 nums[i] + length 来将元素标记，这么做会有加法溢出问题。</p><p>这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上。</p><p>以 (2, 3, 1, 0, 2, 5) 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position-0 : (2,3,1,0,2,5) // 2 &lt;-&gt; 1</span><br><span class="line">             (1,3,2,0,2,5) // 1 &lt;-&gt; 3</span><br><span class="line">             (3,1,2,0,2,5) // 3 &lt;-&gt; 0</span><br><span class="line">             (0,1,2,3,2,5) // already in position</span><br><span class="line">position-1 : (0,1,2,3,2,5) // already in position</span><br><span class="line">position-2 : (0,1,2,3,2,5) // already in position</span><br><span class="line">position-3 : (0,1,2,3,2,5) // already in position</span><br><span class="line">position-4 : (0,1,2,3,2,5) // nums[i] == nums[nums[i]], exit</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span>  <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i ,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-二维数组的查找"><a href="#2-二维数组的查找" class="headerlink" title="2. 二维数组的查找"></a>2. 二维数组的查找</h1><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="直接暴力-复杂度O-n-2-O-1"><a href="#直接暴力-复杂度O-n-2-O-1" class="headerlink" title="直接暴力 复杂度O(n^2) + O(1)"></a>直接暴力 复杂度O(n^2) + O(1)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。"><a href="#因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。" class="headerlink" title="因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。"></a>因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span> || array == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = array.length , cols = array[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; row &amp;&amp; c &gt;=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[r][c] == target) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[r][c] &gt; target) c--;</span><br><span class="line">        <span class="keyword">else</span> r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3. 替换空格"></a>3. 替换空格</h1><p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串中的空格替换成 “%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;We Are Happy&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;We%20Are%20Happy&quot;</span><br></pre></td></tr></table></figure><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接暴力如果是空格则添加不是则保留 复杂度O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    StringBuilder newStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">            newStr.append(<span class="string">'%'</span>);</span><br><span class="line">            newStr.append(<span class="string">'2'</span>);</span><br><span class="line">            newStr.append(<span class="string">'0'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newStr.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-从尾到头打印链表"><a href="#4-从尾到头打印链表" class="headerlink" title="4. 从尾到头打印链表"></a>4. 从尾到头打印链表</h1><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入链表的第一个节点，从尾到头反过来打印出每个结点的值。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-使用栈"><a href="#1-使用栈" class="headerlink" title="(1)使用栈"></a>(1)使用栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123; </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        list.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### (2)使用递归</span><br><span class="line">```java</span><br><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123; </span><br><span class="line">    ArrayList&lt;Integr&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">        list.add(listNode.val);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-重建二叉树"><a href="#5-重建二叉树" class="headerlink" title="5. 重建二叉树"></a>5. 重建二叉树</h1><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder =  [9,3,15,20,7]</span><br></pre></td></tr></table></figure><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>前序遍历的第一个值为树的根节点，在中序遍历中根节点又把树分为左右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] in, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preStart &gt; preEnd || inStart &gt; preEnd)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preStart]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[preStart] == in[i]) &#123;</span><br><span class="line">        root.left = reConstructBinaryTree(pre, preStart + <span class="number">1</span>, preStart + i - inStart, in, inStart, i - <span class="number">1</span>);</span><br><span class="line">        root.right = reConstructBinaryTree(pre, preStart + i - inStart + <span class="number">1</span>, preEnd, in, i + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-二叉树的下一个节点"><a href="#6-二叉树的下一个节点" class="headerlink" title="6. 二叉树的下一个节点"></a>6. 二叉树的下一个节点</h1><p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h1 id="7-用两个栈实现队列"><a href="#7-用两个栈实现队列" class="headerlink" title="7. 用两个栈实现队列"></a>7. 用两个栈实现队列</h1><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>栈和队列的Push操作是一样的，而队列的出队操作是弹出队首元素，栈的出栈操作时弹出栈顶元素(也就是队尾元素)，所以可以用一个辅助栈存下数据栈的pop(),然后数据栈再存下辅助栈的pop()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    stack1.push(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stack1.isEmpty()) &#123;</span><br><span class="line">        stack2.push(stack1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = stack2.pop();</span><br><span class="line">    <span class="keyword">while</span>(!stack2.isEmpty()) &#123;</span><br><span class="line">        stack1.push(stack2.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-斐波那契数列"><a href="#8-斐波那契数列" class="headerlink" title="8. 斐波那契数列"></a>8. 斐波那契数列</h1><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>求斐波那契数列的第 n 项，n &lt;= 39。</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-直接递归，但会存在重复计算的问题。时间复杂度为递归调用树的节点个数O-2-n-空间复杂度为递归调用树的高度O-n-。"><a href="#1-直接递归，但会存在重复计算的问题。时间复杂度为递归调用树的节点个数O-2-n-空间复杂度为递归调用树的高度O-n-。" class="headerlink" title="(1) 直接递归，但会存在重复计算的问题。时间复杂度为递归调用树的节点个数O(2^n),空间复杂度为递归调用树的高度O(n)。"></a>(1) 直接递归，但会存在重复计算的问题。时间复杂度为递归调用树的节点个数O(2^n),空间复杂度为递归调用树的高度O(n)。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用循环模拟。时间复杂度为O-n-空间复杂度为O-1-。"><a href="#2-使用循环模拟。时间复杂度为O-n-空间复杂度为O-1-。" class="headerlink" title="(2) 使用循环模拟。时间复杂度为O(n),空间复杂度为O(1)。"></a>(2) 使用循环模拟。时间复杂度为O(n),空间复杂度为O(1)。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">1</span>, count = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; n-<span class="number">1</span>) &#123;</span><br><span class="line">        sum = i1 + i2;</span><br><span class="line">        i1 = i2;</span><br><span class="line">        i2 = sum;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-跳台阶"><a href="#9-跳台阶" class="headerlink" title="9 跳台阶"></a>9 跳台阶</h1><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result = pre2 + pre1;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10 矩形覆盖"></a>10 矩形覆盖</h1><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</p><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result = pre2 + pre1;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-变态跳台阶"><a href="#11-变态跳台阶" class="headerlink" title="11. 变态跳台阶"></a>11. 变态跳台阶</h1><p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级… 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt;= <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JumpFloorII(target-<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-旋转数组的最小数字"><a href="#12-旋转数组的最小数字" class="headerlink" title="12. 旋转数组的最小数字"></a>12. 旋转数组的最小数字</h1><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。</p><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>旋转数组会把数组分为两部分，并且都部分有序，所以可以用二分查找找出最小的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[mid] &lt; array[high]) &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; array[high]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            (array[mid] == array[high]) high--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array[high];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-矩阵中的路径"><a href="#13-矩阵中的路径" class="headerlink" title="13. 矩阵中的路径"></a>13. 矩阵中的路径</h1><p><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&amp;tqId=11218&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p><h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>感觉是搜索 但写不出来</p><h1 id="14-机器人的运动范围"><a href="#14-机器人的运动范围" class="headerlink" title="14. 机器人的运动范围"></a>14. 机器人的运动范围</h1><p><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&amp;tqId=11219&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p><p>例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p><h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><p>没思路</p><h1 id="15-剪绳子"><a href="#15-剪绳子" class="headerlink" title="15. 剪绳子"></a>15. 剪绳子</h1><p><a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="noopener">Leetcode</a></p><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一根绳子剪成多段，并且使得每段的长度乘积最大。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = 2</span><br><span class="line">return 1 (2 = 1 + 1)</span><br><span class="line"></span><br><span class="line">n = 10</span><br><span class="line">return 36 (10 = 3 + 3 + 4)</span><br></pre></td></tr></table></figure><h2 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-二进制中1的个数"><a href="#16-二进制中1的个数" class="headerlink" title="16. 二进制中1的个数"></a>16. 二进制中1的个数</h1><p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中 1 的个数。</p><h2 id="解题思路-n-amp-n-1"><a href="#解题思路-n-amp-n-1" class="headerlink" title="解题思路 n&amp;(n-1)"></a>解题思路 n&amp;(n-1)</h2><p>该位运算去除 n 的位级表示中最低的那一位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n       : 10110100</span><br><span class="line">n-1     : 10110011</span><br><span class="line">n&amp;(n-1) : 10110000</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-数值的整数次方"><a href="#17-数值的整数次方" class="headerlink" title="17. 数值的整数次方"></a>17. 数值的整数次方</h1><p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。</p><h2 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-直接实现-时间复杂度为O-n"><a href="#1-直接实现-时间复杂度为O-n" class="headerlink" title="(1)直接实现 时间复杂度为O(n)"></a>(1)直接实现 时间复杂度为O(n)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.abs(exponent); i++) &#123;</span><br><span class="line">        result *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span>/result:result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-递归-当-n-2-0时x-xx-的n-2次方-当n-2-1时x-x-x-x-的n-2次方-时间复杂度为O-lgn"><a href="#2-递归-当-n-2-0时x-xx-的n-2次方-当n-2-1时x-x-x-x-的n-2次方-时间复杂度为O-lgn" class="headerlink" title="(2)递归 当 n % 2 == 0时x=(xx)的n/2次方 当n % 2 == 1时x=x (x*x)的n/2次方 时间复杂度为O(lgn)"></a>(2)递归 当 n % 2 == 0时x=(x<em>x)的n/2次方 当n % 2 == 1时x=x</em> (x*x)的n/2次方 时间复杂度为O(lgn)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(exponent == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">        isNegative = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> result = Power(base * base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>((exponent&amp;<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  isNegative ? <span class="number">1</span>/result:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-打印从1到最大的n位数"><a href="#18-打印从1到最大的n位数" class="headerlink" title="18. 打印从1到最大的n位数"></a>18. 打印从1到最大的n位数</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。</p><h2 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h2><p>n较大的时候就会爆数据，大数问题，可以用数组来存数据</p><h1 id="19-在O-1-时间删除链表的节点"><a href="#19-在O-1-时间删除链表的节点" class="headerlink" title="19. 在O(1)时间删除链表的节点"></a>19. 在O(1)时间删除链表的节点</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>在O(1)时间删除链表的节点 </p><h2 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h2><p>① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。</p><p>② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。</p><p>综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2，因此该算法的平均时间复杂度为 O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode tobeDelete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || tobeDelete == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(tobeDelete.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = tobeDelete.next;</span><br><span class="line">        tobeDelete.val = next.val;</span><br><span class="line">        tobeDelete.next = next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(head.next != tobeDelete) </span><br><span class="line">            cur = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="20-删除链表中重复的节点"><a href="#20-删除链表中重复的节点" class="headerlink" title="20. 删除链表中重复的节点"></a>20. 删除链表中重复的节点</h1><p><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h2 id="解题思路-递归删除，如果当前节点的值等于它的下一个节点的值，就递归到不相等的那个节点。如果当前节点的值不等于它的下一个节点的值，则不用删除，递归设置它的下一个节点。"><a href="#解题思路-递归删除，如果当前节点的值等于它的下一个节点的值，就递归到不相等的那个节点。如果当前节点的值不等于它的下一个节点的值，则不用删除，递归设置它的下一个节点。" class="headerlink" title="解题思路 递归删除，如果当前节点的值等于它的下一个节点的值，就递归到不相等的那个节点。如果当前节点的值不等于它的下一个节点的值，则不用删除，递归设置它的下一个节点。"></a>解题思路 递归删除，如果当前节点的值等于它的下一个节点的值，就递归到不相等的那个节点。如果当前节点的值不等于它的下一个节点的值，则不用删除，递归设置它的下一个节点。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">    ListNode next = pHead.next;</span><br><span class="line">    <span class="keyword">if</span>(pHead.val == next.val) &#123;</span><br><span class="line">        <span class="keyword">while</span>(next != <span class="keyword">null</span> &amp;&amp; pHead.val == next.val) &#123;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplication(next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pHead.next = deleteDuplication(pHead.next);</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="21-正则表达式匹配"><a href="#21-正则表达式匹配" class="headerlink" title="21. 正则表达式匹配"></a>21. 正则表达式匹配</h1><p><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括 ‘.’ 和 ‘*‘ 的正则表达式。模式中的字符 ‘.’ 表示任意一个字符，而 ‘*‘ 表示它前面的字符可以出现任意次（包含 0 次）。</p><p>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 “aaa” 与模式 “a.a” 和 “ab*ac*a” 匹配，但是与 “aa.a” 和 “ab*a” 均不匹配。</p><h2 id="解题思路-I-don’t-konw"><a href="#解题思路-I-don’t-konw" class="headerlink" title="解题思路 I don’t konw"></a>解题思路 I don’t konw</h2><h1 id="22-表示数值的字符串"><a href="#22-表示数值的字符串" class="headerlink" title="22. 表示数值的字符串"></a>22. 表示数值的字符串</h1><p><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&amp;tqId=11206&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是</p><h2 id="解题思路-I-don’t-know"><a href="#解题思路-I-don’t-know" class="headerlink" title="解题思路 I don’t know"></a>解题思路 I don’t know</h2><h1 id="23-调整数组顺序使奇数位于偶数前面"><a href="#23-调整数组顺序使奇数位于偶数前面" class="headerlink" title="23. 调整数组顺序使奇数位于偶数前面"></a>23. 调整数组顺序使奇数位于偶数前面</h1><p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-直接模拟-开两个数组来分别存放奇数和偶数，然后再依次改变。但空间复杂度为O-n-，并且代码太啰嗦了。"><a href="#1-直接模拟-开两个数组来分别存放奇数和偶数，然后再依次改变。但空间复杂度为O-n-，并且代码太啰嗦了。" class="headerlink" title="(1)直接模拟 开两个数组来分别存放奇数和偶数，然后再依次改变。但空间复杂度为O(n)，并且代码太啰嗦了。"></a>(1)直接模拟 开两个数组来分别存放奇数和偶数，然后再依次改变。但空间复杂度为O(n)，并且代码太啰嗦了。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] %<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[count1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            a[j++] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[count2];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span> ;i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            b[j++] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count2;i++) &#123;</span><br><span class="line">        array[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = count2,j = <span class="number">0</span>; i &lt; array.length;i++) &#123;</span><br><span class="line">        array[i] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> oddCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a : array) &#123;</span><br><span class="line">        <span class="keyword">if</span>((a&amp;<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            oddCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] nums = array.clone();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> j = oddCount;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>((a&amp;<span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">            array[i++] = a;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            array[j++] = a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-因为冒泡排序的思想使比较相邻元素的大小，可以利用冒泡排序的思想来做。"><a href="#2-因为冒泡排序的思想使比较相邻元素的大小，可以利用冒泡排序的思想来做。" class="headerlink" title="(2)因为冒泡排序的思想使比较相邻元素的大小，可以利用冒泡排序的思想来做。"></a>(2)因为冒泡排序的思想使比较相邻元素的大小，可以利用冒泡排序的思想来做。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((a[j]&amp;<span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (a[j+<span class="number">1</span>]&amp;<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="24-链表中倒数第k个节点"><a href="#24-链表中倒数第k个节点" class="headerlink" title="24. 链表中倒数第k个节点"></a>24. 链表中倒数第k个节点</h1><p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer的实现 参考文章&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://soleslie.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://soleslie.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>第三章——对象的共享</title>
    <link href="https://soleslie.github.io/2018/11/18/JavaConcurrencyinPractice/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/"/>
    <id>https://soleslie.github.io/2018/11/18/JavaConcurrencyinPractice/第三章——对象的共享/</id>
    <published>2018-11-18T06:33:31.000Z</published>
    <updated>2018-11-23T05:09:51.235Z</updated>
    
    <content type="html"><![CDATA[<p>第二章的开头曾指出，要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要正确的管理。第二章介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据，而本章将介绍如何共享和发布对象，从而是他们能够安全地由多个线程同时访问。<br><a id="more"></a></p><h1 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h1><p>可见性是一种复杂的属性， 因为可见性中的错误总会违背我们的直觉。为了确保线程之间对内存的写入操作的可见性，必须使用同步机制。</p><pre><code>public class NoVisibility {    private static boolean ready;    private static int number;    private static class ReaderThread extends Thread {        @Override        public void run() {            while(!ready) {                Thread.yield();                System.out.println(number);            }        }    }    public static void main(String[] args) {        new ReaderThead().start();        number = 42;        ready = true;    }</code></pre><p>}</p><h2 id="3-1-1-失效数据"><a href="#3-1-1-失效数据" class="headerlink" title="3.1.1 失效数据"></a>3.1.1 失效数据</h2><p>Novisibility中展示了在缺乏同步的程序中可能产生错误结果的一种情况：失效数据源。</p><h2 id="3-1-2-非原子的64位操作"><a href="#3-1-2-非原子的64位操作" class="headerlink" title="3.1.2 非原子的64位操作"></a>3.1.2 非原子的64位操作</h2><p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性也被称为最低安全性。</p><p>最低安全性适用于绝大多数的变量，但是有一个例外：非volatile类型的64位的数值变量(double、long)。对于非volatile类型的long和double变量的读取和写入是非原子的。</p><h2 id="3-1-3-加锁与可见性"><a href="#3-1-3-加锁与可见性" class="headerlink" title="3.1.3 加锁与可见性"></a>3.1.3 加锁与可见性</h2><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能够看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在一个锁上进行同步。</p><h2 id="3-1-4-volatile变量"><a href="#3-1-4-volatile变量" class="headerlink" title="3.1.4 volatile变量"></a>3.1.4 volatile变量</h2><p>在访问volatile变量时不会执行加锁操作，因此也就不会执行线程阻塞，因此volatile时是一种比synchronized关键字更轻量的同步机制。</p><p>volatile变量通常用作标志位，标识状态的改变。但是volatile的语义不足以确保递增操作(count++)的原子性，原子变量提供了”读-改-写”的原子操作，常常用作一种更好的”volatile”变量。</p><p>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。</p><h1 id="3-2-发布与溢出"><a href="#3-2-发布与溢出" class="headerlink" title="3.2 发布与溢出"></a>3.2 发布与溢出</h1><p>“发布”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布改对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就称为溢出。</p><p>对于类中外部方法(既不是私有的方法也不是终结final方法)，当把一个对象传递给某个外部方法，就相当于发布了这个对象。</p><p>this引用溢出的详细介绍：<a href="https://blog.csdn.net/flysqrlboy/article/details/10607295" target="_blank" rel="noopener">传送门</a></p><h1 id="3-3-线程封闭"><a href="#3-3-线程封闭" class="headerlink" title="3.3 线程封闭"></a>3.3 线程封闭</h1><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术称为线程封闭，它是实现线程安全性的最简单方式之一</p><h2 id="3-3-1-Ad-hoc线程封闭"><a href="#3-3-1-Ad-hoc线程封闭" class="headerlink" title="3.3.1 Ad-hoc线程封闭"></a>3.3.1 Ad-hoc线程封闭</h2><p>Ad-hoc线程封闭是指，维护线程的封闭性的职责完全由程序实现来承担。不推荐使用</p><h2 id="3-3-2-栈封闭"><a href="#3-3-2-栈封闭" class="headerlink" title="3.3.2 栈封闭"></a>3.3.2 栈封闭</h2><p>栈封闭是线程封闭的一种特列，在栈封闭中，只有通过局部变量才能访问对象。</p><h2 id="3-3-3-ThreadLocal类-看源码"><a href="#3-3-3-ThreadLocal类-看源码" class="headerlink" title="3.3.3 ThreadLocal类(看源码)"></a>3.3.3 ThreadLocal类(看源码)</h2><p>使用线程封闭的一种更规范的方法是ThreadLocal，这个类能使线程的某个值与保存值得对象关联起来。ThreadLocal提供了get和set等访问接口的方法，这些方法位每个使用该变量的线程都存有一份独立的副本，因此get方法总能返回由当前线在tiaoyongset设置的最新值。</p><p>ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。</p><h1 id="3-4-不变性"><a href="#3-4-不变性" class="headerlink" title="3.4 不变性"></a>3.4 不变性</h1><p>满足同步需求的另一种方法是使用不可变对象。如果某个对象在被创建以后其状态不可改变，那么这个对象就被称为不可变对象。不可变对象一定线程安全的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章的开头曾指出，要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要正确的管理。第二章介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据，而本章将介绍如何共享和发布对象，从而是他们能够安全地由多个线程同时访问。&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程实战" scheme="https://soleslie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Java Concurrency in Practice" scheme="https://soleslie.github.io/tags/Java-Concurrency-in-Practice/"/>
    
  </entry>
  
  <entry>
    <title>java多线程 (二) ——创建与启动</title>
    <link href="https://soleslie.github.io/2018/11/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B2-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>https://soleslie.github.io/2018/11/15/Java多线程/java多线程2-创建与启动/</id>
    <published>2018-11-15T07:12:08.000Z</published>
    <updated>2018-11-15T07:45:09.895Z</updated>
    
    <content type="html"><![CDATA[<p>一、定义线程<br>1、扩展java.lang.Thread类</p><p>此类中有个run()方法，应该注意其用法：</p><pre><code>public void run()如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。Thread 的子类应该重写该方法。</code></pre><a id="more"></a><p>2、实现java.lang.Runnable接口</p><pre><code>void run()使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run 方法。方法 run 的常规协定是，它可能执行任何所需的操作。</code></pre><p>二、实例化线程</p><pre><code>1、如果是扩展java.lang.Thread类的线程，则直接new即可。2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法：Thread(Runnable target)Thread(Runnable target, String name)Thread(ThreadGroup group, Runnable target)Thread(ThreadGroup group, Runnable target, String name)Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code></pre><p>三、启动线程</p><p>在线程的Thread对象上调用start()方法，而不是run()或者别的方法。</p><p>在调用start()方法之前：线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。</p><p>在调用start()方法之后：发生了一系列复杂的事情</p><p>启动新的执行线程（具有新的调用栈）；</p><p>该线程从新状态转移到可运行状态；</p><p>当该线程获得机会执行时，其目标run()方法将运行。</p><p>注意：对Java来说，run()方法没有任何特别之处。像main()方法一样，它只是新线程知道调用的方法名称(和签名)。因此，在Runnable上或者Thread上调用run方法是合法的。但并不启动新的线程。<br>四、例子<br>1、实现Runnable接口的多线程例子</p><pre><code>/** * 实现Runnable接口的类 * * @author leizhimin 2008-9-13 18:12:10 */     public class DoSomething implements Runnable {         private String name;     public DoSomething(String name) {         this.name = name;     }     public void run() {      for (int i = 0; i &lt; 5; i++) {         for (long k = 0; k &lt; 100000000; k++) ;         System.out.println(name + &quot;: &quot; + i);     } } }/** * 测试Runnable类实现的多线程程序 * * @author leizhimin 2008-9-13 18:15:02 */ public class TestRunnable {     public static void main(String[] args) {         DoSomething ds1 = new DoSomething(&quot;阿三&quot;);         DoSomething ds2 = new DoSomething(&quot;李四&quot;);         Thread t1 = new Thread(ds1);         Thread t2 = new Thread(ds2);         t1.start();         t2.start();     } }</code></pre><p>执行结果：</p><p>李四: 0<br>阿三: 0<br>李四: 1<br>阿三: 1<br>李四: 2<br>李四: 3<br>阿三: 2<br>李四: 4<br>阿三: 3<br>阿三: 4<br>Process finished with exit code 0</p><p>2、扩展Thread类实现的多线程例子</p><pre><code>/** * 测试扩展Thread类实现的多线程程序 * * @author leizhimin 2008-9-13 18:22:13 */ public class TestThread extends Thread{     public TestThread(String name) {         super(name);     }     public void run() {         for(int i = 0;i&lt;5;i++){             for(long k= 0; k &lt;100000000;k++);             System.out.println(this.getName()+&quot; :&quot;+i);         }     }     public static void main(String[] args) {         Thread t1 = new TestThread(&quot;阿三&quot;);         Thread t2 = new TestThread(&quot;李四&quot;);         t1.start();         t2.start();     } }</code></pre><p>执行结果：</p><p>阿三 :0<br>李四 :0<br>阿三 :1<br>李四 :1<br>阿三 :2<br>李四 :2<br>阿三 :3<br>阿三 :4<br>李四 :3<br>李四 :4<br>Process finished with exit code 0</p><p>对于上面的多线程程序代码来说，输出的结果是不确定的。其中的一条语句for(long k= 0; k &lt;100000000;k++);是用来模拟一个非常耗时的操作的。<br>五、一些常见问题</p><p>1、线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。</p><p>2、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。</p><p>3、获取当前线程的对象的方法是：Thread.currentThread()；</p><p>4、在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。</p><p>5、当线程目标run()方法结束时该线程完成。</p><p>6、一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。</p><p>7、线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。</p><p>众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。</p><p>8、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列唱呢个一个队列的事实。</p><p>9、尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、定义线程&lt;br&gt;1、扩展java.lang.Thread类&lt;/p&gt;
&lt;p&gt;此类中有个run()方法，应该注意其用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void run()

如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。

Thread 的子类应该重写该方法。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="java多线程" scheme="https://soleslie.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="-多线程 -并发" scheme="https://soleslie.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java多线程 (一) ——概念和原理</title>
    <link href="https://soleslie.github.io/2018/11/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E5%A4%9A%E7%BA%BF%E7%A8%8B1-%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://soleslie.github.io/2018/11/13/Java多线程/java多线程1-概念和原理/</id>
    <published>2018-11-13T05:51:20.000Z</published>
    <updated>2018-11-15T06:36:48.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、操作系统中进程和线程的概念"><a href="#一、操作系统中进程和线程的概念" class="headerlink" title="一、操作系统中进程和线程的概念"></a>一、操作系统中进程和线程的概念</h1><p>现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。</p><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。<br><a id="more"></a><br>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。</p><p>“同时”执行是人的感觉，在线程之间实际上轮换执行。 </p><h1 id="二、Java中的线程"><a href="#二、Java中的线程" class="headerlink" title="二、Java中的线程"></a>二、Java中的线程</h1><p>在Java中，线程可以代指两件不同的事情</p><ol><li>java.lang.Thread 的一个实例</li><li>线程的运行</li></ol><p>java线程的基本知识:</p><p>使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。</p><p>一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。</p><p>Java中，每个线程都有一个调用栈。 </p><p>一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。</p><p>一旦创建一个新的线程，就产生一个新的调用栈。</p><p>线程总体分两类：用户线程和守护线程。</p><p>当所有用户线程执行完毕的时候，JVM自动关闭。但是守护线程却不独立于JVM，守护线程一般是由操作系统或者用户自己创建的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、操作系统中进程和线程的概念&quot;&gt;&lt;a href=&quot;#一、操作系统中进程和线程的概念&quot; class=&quot;headerlink&quot; title=&quot;一、操作系统中进程和线程的概念&quot;&gt;&lt;/a&gt;一、操作系统中进程和线程的概念&lt;/h1&gt;&lt;p&gt;现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。&lt;/p&gt;
&lt;p&gt;进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。&lt;br&gt;
    
    </summary>
    
      <category term="java多线程" scheme="https://soleslie.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://soleslie.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://soleslie.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>leslie</title>
    <link href="https://soleslie.github.io/2018/11/09/leslie/"/>
    <id>https://soleslie.github.io/2018/11/09/leslie/</id>
    <published>2018-11-09T08:56:28.000Z</published>
    <updated>2018-11-21T08:37:08.364Z</updated>
    
    <content type="html"><![CDATA[<p>时间是个让人触不及防的东西，真的没想到我竟然快要毕业了，仿佛一切都还刚发生，好像我还是那个高考失败发誓要在大学里面好好学习的高中生，一切都好像历历在目。可是我好像又失败了，在大学也没好好学习。我还依稀记得我在高考失败信誓旦旦的说我一定会好好学习的，我也不知道多少个夜晚我都发誓说要好好学习，可第二天它就被我抛弃了。可是直到找工作的时候，我才明白自己的处境，知道自己是那么的不堪。“不优秀不可怕，可怕的是知道自己不优秀还不努力”这句话应该就是我真实的写照吧。</p><p>回首大学岁月，让我最后悔的就是放弃acm吧，让我现在离梦想那么远，跟别人差距那么大，我羡慕别人，可是发现这一切都是我应得的。你有多努力，就有多幸运。我倒下了。哦，对了，大学没谈一场轰天动地的恋爱也是很遗憾啊，也许这辈子就单身了。哈哈哈哈哈哈</p><p>奉劝各位还在读大学的象牙塔的学生们，该学习的时候一定好好学习，顺便谈一场属于自己的学生时代的恋爱。</p><pre><code>Hello World 不知道现在努力还来的及码？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间是个让人触不及防的东西，真的没想到我竟然快要毕业了，仿佛一切都还刚发生，好像我还是那个高考失败发誓要在大学里面好好学习的高中生，一切都好像历历在目。可是我好像又失败了，在大学也没好好学习。我还依稀记得我在高考失败信誓旦旦的说我一定会好好学习的，我也不知道多少个夜晚我都发
      
    
    </summary>
    
      <category term="大学生活" scheme="https://soleslie.github.io/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活感悟" scheme="https://soleslie.github.io/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
      <category term="杂谈" scheme="https://soleslie.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
