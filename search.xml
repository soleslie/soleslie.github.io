<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java集合详解3-Iterator,fail-fast机制，比较器</title>
      <link href="/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A33/"/>
      <url>/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A33/</url>
      
        <content type="html"><![CDATA[<p><a href="https://h2pl.github.io/2018/05/09/collection3/" target="_blank" rel="noopener">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合详解2——LinkedList,Queue</title>
      <link href="/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A32/"/>
      <url>/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A32/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList概述</p><p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。<br><a id="more"></a><br>LinkedList实现所有可选的列表操作，并允许所有的元素包括null。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 、和insert元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p><p>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。</p><p>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。</p><p>同时，与ArrayList一样此实现不是同步的。</p><p>（以上摘自JDK 6.0 API）。</p><p>源码分析</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>首先我们先看LinkedList的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">      从这段代码中我们可以清晰地看出<span class="title">LinkedList</span>继承<span class="title">AbstractSequentialList</span>，实现<span class="title">List</span>、<span class="title">Deque</span>、<span class="title">Cloneable</span>、<span class="title">Serializable</span>。其中<span class="title">AbstractSequentialList</span>提供了 <span class="title">List</span> 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现<span class="title">List</span>接口的复杂度。<span class="title">Deque</span>一个线性 <span class="title">collection</span>，支持在两端插入和移除元素，定义了双端队列的操作。</span></span><br></pre></td></tr></table></figure></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在LinkedList中提供了两个基本属性size、header</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry header = <span class="keyword">new</span> Entry(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E element;        <span class="comment">//元素节点</span></span><br><span class="line">    Entry&lt;E&gt; next;    <span class="comment">//下一个元素</span></span><br><span class="line">    Entry&lt;E&gt; previous;  <span class="comment">//上一个元素</span></span><br><span class="line"></span><br><span class="line">    Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.previous = previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>LinkedList提供了两个构造方法：LinkedList()和LinkedList(Collection&lt;? extends E&gt; c)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构造一个空列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        header.next = header.previous = header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>LinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。</p><p>LinkedList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;    <span class="comment">//插入元素的个数</span></span><br><span class="line">    <span class="comment">//若插入的元素为空，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//modCount:在AbstractList中定义的，表示从结构上修改列表的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点</span></span><br><span class="line">    Entry&lt;E&gt; successor = (index == size ? header : entry(index));</span><br><span class="line">    <span class="comment">//插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素</span></span><br><span class="line">    Entry&lt;E&gt; predecessor = successor.previous;</span><br><span class="line">    <span class="comment">//执行插入动作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numNew; i++) &#123;</span><br><span class="line">        <span class="comment">//构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Entry&lt;E&gt; e = <span class="keyword">new</span> Entry&lt;E&gt;((E) a[i], successor, predecessor);</span><br><span class="line">        <span class="comment">//将插入位置前一个节点的下一个元素引用指向当前元素</span></span><br><span class="line">        predecessor.next = e;</span><br><span class="line">        <span class="comment">//修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序</span></span><br><span class="line">        predecessor = e;</span><br><span class="line">    &#125;</span><br><span class="line">    successor.previous = predecessor;</span><br><span class="line">    <span class="comment">//修改容量大小</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">  在addAll()方法中，涉及到了两个方法，一个是entry(<span class="keyword">int</span> index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定位置(若存在)的节点元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">entry</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + index + <span class="string">", Size: "</span></span><br><span class="line">                    + size);</span><br><span class="line">        <span class="comment">//头部节点</span></span><br><span class="line">        Entry&lt;E&gt; e = header;</span><br><span class="line">        <span class="comment">//判断遍历的方向</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++)</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--)</span><br><span class="line">                e = e.previous;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。</p><p>由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。</p><h2 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h2><p>  add(E e): 将指定元素添加到此列表的结尾。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addBefore(e, header);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      该方法调用addBefore方法，然后直接返回<span class="keyword">true</span>，对于addBefore()而已，它为LinkedList的私有方法。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">addBefore</span><span class="params">(E e, Entry&lt;E&gt; entry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//利用Entry构造函数构建一个新节点 newEntry，</span></span><br><span class="line">        Entry&lt;E&gt; newEntry = <span class="keyword">new</span> Entry&lt;E&gt;(e, entry, entry.previous);</span><br><span class="line">        <span class="comment">//修改newEntry的前后节点的引用，确保其链表的引用关系是正确的</span></span><br><span class="line">        newEntry.previous.next = newEntry;</span><br><span class="line">        newEntry.next.previous = newEntry;</span><br><span class="line">        <span class="comment">//容量+1</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//修改次数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> newEntry;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。</p><p>LinkedList还提供了其他的增加方法：</p><p>add(int index, E element)：在此列表中指定的位置插入指定的元素。</p><p>addAll(Collection&lt;? extends E&gt; c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。</p><p>addAll(int index, Collection&lt;? extends E&gt; c)：将指定 collection 中的所有元素从指定位置开始插入此列表。</p><p>AddFirst(E e): 将指定元素插入此列表的开头。</p><p>addLast(E e): 将指定元素添加到此列表的结尾。</p><h2 id="移除方法"><a href="#移除方法" class="headerlink" title="移除方法"></a>移除方法</h2><p>  remove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.element==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    remove(e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(e.element)) &#123;</span><br><span class="line">                    remove(e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">该方法首先会判断移除的元素是否为<span class="keyword">null</span>，然后迭代这个链表找到该元素节点，最后调用remove(Entry e)，remove(Entry e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">remove</span><span class="params">(Entry&lt;E&gt; e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == header)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保留被移除的元素：要返回</span></span><br><span class="line">        E result = e.element;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将该节点的前一节点的next指向该节点后节点</span></span><br><span class="line">        e.previous.next = e.next;</span><br><span class="line">        <span class="comment">//将该节点的后一节点的previous指向该节点的前节点</span></span><br><span class="line">        <span class="comment">//这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的</span></span><br><span class="line">        e.next.previous = e.previous;</span><br><span class="line">        <span class="comment">//将该节点归空</span></span><br><span class="line">        e.next = e.previous = <span class="keyword">null</span>;</span><br><span class="line">        e.element = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的移除方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">clear()： 从此列表中移除所有元素。</span><br><span class="line"></span><br><span class="line">remove()：获取并移除此列表的头（第一个元素）。</span><br><span class="line"></span><br><span class="line">remove(<span class="keyword">int</span> index)：移除此列表中指定位置处的元素。</span><br><span class="line"></span><br><span class="line">remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。</span><br><span class="line"></span><br><span class="line">removeFirst()：移除并返回此列表的第一个元素。</span><br><span class="line"></span><br><span class="line">removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。</span><br><span class="line"></span><br><span class="line">removeLast()：移除并返回此列表的最后一个元素。</span><br><span class="line"></span><br><span class="line">removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。</span><br></pre></td></tr></table></figure><h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><p>对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="keyword">int</span> index)：返回此列表中指定位置处的元素。</span><br><span class="line"></span><br><span class="line">getFirst()：返回此列表的第一个元素。</span><br><span class="line"></span><br><span class="line">getLast()：返回此列表的最后一个元素。</span><br><span class="line"></span><br><span class="line">indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue接口定义了队列数据结构，元素是有序的(按插入顺序)，先进先出。</p><h2 id="DeQueue"><a href="#DeQueue" class="headerlink" title="DeQueue"></a>DeQueue</h2><p>DeQueue(Double-ended queue)为接口，继承了Queue接口，创建双向队列，灵活性更强，可以前向或后向迭代，在队头队尾均可心插入或删除元素。它的两个主要实现类是ArrayDeque和LinkedList。</p><h2 id="ArrayDeque-（底层使用循环数组实现双向队列）"><a href="#ArrayDeque-（底层使用循环数组实现双向队列）" class="headerlink" title="ArrayDeque （底层使用循环数组实现双向队列）"></a>ArrayDeque （底层使用循环数组实现双向队列）</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 默认容量为16</span></span><br><span class="line">   elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 指定容量的构造函数</span></span><br><span class="line">   allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;<span class="comment">// 最小容量为8</span></span><br><span class="line">        <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">        <span class="comment">// Tests "&lt;=" because arrays aren't kept full.</span></span><br><span class="line">        <span class="comment">// 如果要分配的容量大于等于8，扩大成2的幂（是为了维护头、尾下标值）；否则使用最小容量8</span></span><br><span class="line">        <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            initialCapacity++;</span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">                initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">        &#125;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="add操作"><a href="#add操作" class="headerlink" title="add操作"></a>add操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">add(E e) 调用 addLast(E e) 方法：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"e == null"</span>);</span><br><span class="line">   elements[tail] = e; <span class="comment">// 根据尾索引，添加到尾端</span></span><br><span class="line">   <span class="comment">// 尾索引+1，并与数组（length - 1）进行取‘&amp;’运算，因为length是2的幂，所以（length-1）转换为2进制全是1，</span></span><br><span class="line">   <span class="comment">// 所以如果尾索引值 tail 小于等于（length - 1），那么‘&amp;’运算后仍为 tail 本身；如果刚好比（length - 1）大1时，</span></span><br><span class="line">   <span class="comment">// ‘&amp;’运算后 tail 便为0（即回到了数组初始位置）。正是通过与（length - 1）进行取‘&amp;’运算来实现数组的双向循环。</span></span><br><span class="line">   <span class="comment">// 如果尾索引和头索引重合了，说明数组满了，进行扩容。</span></span><br><span class="line">   <span class="keyword">if</span> ((tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">      doubleCapacity();<span class="comment">// 扩容为原来的2倍</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addFirst(E e) 的实现：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"e == null"</span>);</span><br><span class="line">   <span class="comment">// 此处如果head为0，则-1（1111 1111 1111 1111 1111 1111 1111 1111）与（length - 1）进行取‘&amp;’运算，结果必然是（length - 1），即回到了数组的尾部。</span></span><br><span class="line">   elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">   <span class="comment">// 如果尾索引和头索引重合了，说明数组满了，进行扩容</span></span><br><span class="line">   <span class="keyword">if</span> (head == tail)</span><br><span class="line">      doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">remove()方法最终都会调对应的poll()方法：</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = head;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E result = (E) elements[h];</span><br><span class="line">        <span class="comment">// Element is null if deque empty</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">        <span class="comment">// 头索引 + 1</span></span><br><span class="line">        head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尾索引 - 1</span></span><br><span class="line">        <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E result = (E) elements[t];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[t] = <span class="keyword">null</span>;</span><br><span class="line">        tail = t;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="PriorityQueue（底层用数组实现堆的结构）"><a href="#PriorityQueue（底层用数组实现堆的结构）" class="headerlink" title="PriorityQueue（底层用数组实现堆的结构）"></a>PriorityQueue（底层用数组实现堆的结构）</h2><p>优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。 而优先队列每次拿数据的时候都会拿出优先级最高的数据。</p><p>优先队列内部维护着一个堆，每次取数据的时候都从堆顶拿数据（堆顶的优先级最高），这就是优先队列的原理。</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e); <span class="comment">// add方法内部调用offer方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="comment">// 元素为空的话，抛出NullPointerException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length) <span class="comment">// 如果当前用堆表示的数组已经满了，调用grow方法扩容</span></span><br><span class="line">        grow(i + <span class="number">1</span>); <span class="comment">// 扩容</span></span><br><span class="line">    size = i + <span class="number">1</span>; <span class="comment">// 元素个数+1</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="comment">// 堆还没有元素的情况</span></span><br><span class="line">        queue[<span class="number">0</span>] = e; <span class="comment">// 直接给堆顶赋值元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 堆中已有元素的情况</span></span><br><span class="line">        siftUp(i, e); <span class="comment">// 重新调整堆，从下往上调整，因为新增元素是加到最后一个叶子节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)  <span class="comment">// 比较器存在的情况下</span></span><br><span class="line">        siftUpUsingComparator(k, x); <span class="comment">// 使用比较器调整</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 比较器不存在的情况下</span></span><br><span class="line">        siftUpComparable(k, x); <span class="comment">// 使用元素自身的比较器调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123; <span class="comment">// 一直循环直到父节点还存在</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 找到父节点索引，等同于（k - 1）/ 2</span></span><br><span class="line">        Object e = queue[parent]; <span class="comment">// 获得父节点元素</span></span><br><span class="line">        <span class="comment">// 新元素与父元素进行比较，如果满足比较器结果，直接跳出，否则进行调整</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e; <span class="comment">// 进行调整，新位置的元素变成了父元素</span></span><br><span class="line">        k = parent; <span class="comment">// 新位置索引变成父元素索引，进行递归操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x; <span class="comment">// 新添加的元素添加到堆中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll，出队方法"><a href="#poll，出队方法" class="headerlink" title="poll，出队方法"></a>poll，出队方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size; <span class="comment">// 元素个数-1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>]; <span class="comment">// 得到堆顶元素</span></span><br><span class="line">    E x = (E) queue[s]; <span class="comment">// 最后一个叶子节点</span></span><br><span class="line">    queue[s] = <span class="keyword">null</span>; <span class="comment">// 最后1个叶子节点置空</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x); <span class="comment">// 从上往下调整，因为删除元素是删除堆顶的元素</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) <span class="comment">// 比较器存在的情况下</span></span><br><span class="line">        siftDownUsingComparator(k, x); <span class="comment">// 使用比较器调整</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 比较器不存在的情况下</span></span><br><span class="line">        siftDownComparable(k, x); <span class="comment">// 使用元素自身的比较器调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 只需循环节点个数的一般即可</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 得到父节点的左子节点索引，即（k * 2）+ 1</span></span><br><span class="line">        Object c = queue[child]; <span class="comment">// 得到左子元素</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>; <span class="comment">// 得到父节点的右子节点索引</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>) <span class="comment">// 左子节点跟右子节点比较，取更大的值</span></span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)  <span class="comment">// 然后这个更大的值跟最后一个叶子节点比较</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c; <span class="comment">// 新位置使用更大的值</span></span><br><span class="line">        k = child; <span class="comment">// 新位置索引变成子元素索引，进行递归操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x; <span class="comment">// 最后一个叶子节点添加到合适的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove，删除队列元素"><a href="#remove，删除队列元素" class="headerlink" title="remove，删除队列元素"></a>remove，删除队列元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o); <span class="comment">// 找到数据对应的索引</span></span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>) <span class="comment">// 不存在的话返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 存在的话调用removeAt方法，返回true</span></span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size; <span class="comment">// 元素个数-1</span></span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// 如果是删除最后一个叶子节点</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>; <span class="comment">// 直接置空，删除即可，堆还是保持特质，不需要调整</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 如果是删除的不是最后一个叶子节点</span></span><br><span class="line">        E moved = (E) queue[s]; <span class="comment">// 获得最后1个叶子节点元素</span></span><br><span class="line">        queue[s] = <span class="keyword">null</span>; <span class="comment">// 最后1个叶子节点置空</span></span><br><span class="line">        siftDown(i, moved); <span class="comment">// 从上往下调整</span></span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123; <span class="comment">// 如果从上往下调整完毕之后发现元素位置没变，从下往上调整</span></span><br><span class="line">            siftUp(i, moved); <span class="comment">// 从下往上调整</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行 siftDown() 下滤过程：</p><p>(<a href="https://upload-images.jianshu.io/upload_images/195193-a64dbb5508a9c668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/195193-a64dbb5508a9c668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642</a>)</p><p>再执行 siftUp() 上滤过程：<br>(<a href="https://upload-images.jianshu.io/upload_images/195193-e9ad437213e69b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/195193-e9ad437213e69b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633</a>)</p><h2 id="总结和同步的问题"><a href="#总结和同步的问题" class="headerlink" title="总结和同步的问题"></a>总结和同步的问题</h2><p>1、jdk内置的优先队列PriorityQueue内部使用一个堆维护数据，每当有数据add进来或者poll出去的时候会对堆做从下往上的调整和从上往下的调整。</p><p>2、PriorityQueue不是一个线程安全的类，如果要在多线程环境下使用，可以使用 PriorityBlockingQueue 这个优先阻塞队列。其中add、poll、remove方法都使用 ReentrantLock 锁来保持同步，take() 方法中如果元素为空，则会一直保持阻塞</p><p>本文转载自：<a href="https://h2pl.github.io/2018/05/09/collection2/" target="_blank" rel="noopener">h2pl</a> <a href="https://h2pl.github.io/2018/05/09/collection2/" target="_blank" rel="noopener">https://h2pl.github.io/2018/05/09/collection2/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java集合详解 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合详解1——ArrayList,Vector,Stack</title>
      <link href="/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A31/"/>
      <url>/2018/11/21/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A31/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h1><h2 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h2><p>ArrayList是实现List接口的动态数组，所谓动态就是它的大小是可变的。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。<br><a id="more"></a></p><p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。默认初始容量为10。随着ArrayList中元素的增加，它的容量也会不断的自动增长。</p><p>在每次添加新的元素时，ArrayList都会检查是否需要进行扩容操作，扩容操作带来数据向新数组的重新拷贝，所以如果我们知道具体业务数据量，在构造ArrayList时可以给ArrayList指定一个初始容量，这样就会减少扩容时数据的拷贝问题。当然在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p><p>注意，ArrayList实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。所以为了保证同步，最好的办法是在创建时完成，以防止意外对列表进行不同步的访问：</p><p>List list = Collections.synchronizedList(new ArrayList(…)); </p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>ArrayList的底层是一个object数组，并且由trasient修饰。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"></span><br><span class="line">non-<span class="keyword">private</span> to simplify nested <span class="class"><span class="keyword">class</span> <span class="title">access</span></span></span><br><span class="line"><span class="class"><span class="title">ArrayList</span>底层数组不会参与序列化，而是使用另外的序列化方式。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">使用<span class="title">writeobject</span>方法进行序列化,具体为什么这么做欢迎查看我之前的关于序列化的文章</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">总结一下就是只复制数组中有值的位置，其他未赋值的位置不进行序列化，可以节省空间。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">void</span> <span class="title">writeObject</span>(<span class="title">java</span>.<span class="title">io</span>.<span class="title">ObjectOutputStream</span> <span class="title">s</span>)</span></span><br><span class="line"><span class="class">        <span class="title">throws</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">IOException</span> </span>&#123;</span><br><span class="line">         Write out element count, and any hidden stuff</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         s.defaultWriteObject();</span><br><span class="line">         Write out size as capacity <span class="keyword">for</span> behavioural compatibility with clone</span><br><span class="line">            s.writeInt(size);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                s.writeObject(elementData[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>添加元素时，首先判断索引是否合法，然后检测是否需要扩容，最后使用System.arraycopy方法来完成数组的复制。</p><p>这个方法无非就是使用System.arraycopy()方法将C集合(先准换为数组)里面的数据复制到elementData数组中。这里就稍微介绍下System.arraycopy()，因为下面还将大量用到该方法。该方法的原型为：</p><p>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)。</p><p>它的根本目的就是进行数组元素的复制。即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p><p>将源数组src从srcPos位置开始复制到dest数组中，复制长度为length，数据从dest的destPos位置开始粘贴。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);   Increments modCount!!</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">    &#125;</span><br><span class="line">删除元素时，同样判断索引是否和法，删除的方式是把被删除元素右边的元素左移，方法同样是使用System.arraycopy进行拷贝。</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;  clear to let GC <span class="keyword">do</span> its work</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ArrayList提供一个清空数组的办法，方法是将所有元素置为null，这样就可以让GC自动回收掉没有被引用的元素了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment">    * be empty after this call returns.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">     clear to let GC <span class="keyword">do</span> its work</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>修改元素时，只需要检查下标即可进行修改操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;            </span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述方法都使用了rangeCheck方法，其实就是简单地检查下标而已。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>由以上代码可以看出，在一个迭代器初始的时候会赋予它调用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存储的mcount不一样那就抛异常，也就是Fail-Fast 机制，我们知道 java.util.ArrayList 不是线程安全的，ArrayList，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对ArrayList内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了ArrayList，<strong>所以在这里和大家建议，当大家遍历那些非线程安全的数据结构时，尽量使用迭代器。</strong></p><h2 id="初始容量和扩容方式"><a href="#初始容量和扩容方式" class="headerlink" title="初始容量和扩容方式"></a>初始容量和扩容方式</h2><p>初始容量是10，下面是扩容方法。<br>首先先取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>扩容发生在add元素时，传入当前元素容量加一<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);   Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里给出初始化时的数组<br>    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</p><p>这说明：如果数组还是初始数组，那么最小的扩容大小就是size+1和初始容量中较大的一个，初始容量为10。<br>因为addall方法也会调用该函数，所以此时需要做判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">开始精确地扩容</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">     overflow-conscious code</span><br><span class="line">    如果此时扩容容量大于数组长度吗，执行grow，否则不执行。</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真正执行扩容的方法grow,扩容方式是让新容量等于旧容量的1.5倍。当新容量大于最大数组容量时，执行大数扩容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     overflow-conscious code</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">         minCapacity is usually close to size, so <span class="keyword">this</span> is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当新容量大于最大数组长度，有两种情况，一种是溢出，抛异常，一种是没溢出，返回整数的最大值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)  overflow</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里有一个疑问，为什么每次扩容处理会是1.5倍，而不是2.5、3、4倍呢？通过google查找，发现1.5倍的扩容是最好的倍数。因为一次性扩容太大(例如2.5倍)可能会浪费更多的内存(1.5倍最多浪费33%，而2.5被最多会浪费60%，3.5倍则会浪费71%……)。但是一次性扩容太小，需要多次对数组重新分配内存，对性能消耗比较严重。所以1.5倍刚刚好，既能满足性能需求，也不会造成很大的内存消耗。</p><p>处理这个ensureCapacity()这个扩容数组外，ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize()方法来实现。该方法可以最小化ArrayList实例的存储量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; oldCapacity) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>ArrayList是线程不安全的。在其迭代器iteator中，如果有多线程操作导致modcount改变，会执行fast-fail,抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector简介</p><p>Vector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。</p><p>Vector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍历等功能。</p><p>Vector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。</p><p>Vector 实现了Cloneable接口，支持clone()方法，可以被克隆。</p><p>vector底层数组不加transient，序列化时会全部复制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br><span class="line">    <span class="keyword">final</span> Object[] data;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        fields.put(<span class="string">"capacityIncrement"</span>, capacityIncrement);</span><br><span class="line">        fields.put(<span class="string">"elementCount"</span>, elementCount);</span><br><span class="line">        data = elementData.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    fields.put(<span class="string">"elementData"</span>, data);</span><br><span class="line">    s.writeFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h2><p>vector的增删改查既提供了自己的实现，也继承了abstractList抽象类的部分方法。<br>下面的方法是vector自己实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">            elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">            elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount--;</span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">        + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line"> &#125;</span><br><span class="line"> ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line"> System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line"> elementData[index] = obj;</span><br><span class="line"> elementCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始容量和扩容"><a href="#初始容量和扩容" class="headerlink" title="初始容量和扩容"></a>初始容量和扩容</h2><p>扩容方式与ArrayList基本一样，但是扩容时不是1.5倍扩容，而是有一个扩容增量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>capacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   overflow-conscious code</span><br><span class="line">   <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   overflow-conscious code</span><br><span class="line">   <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">   <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">    capacityIncrement : oldCapacity);</span><br><span class="line">   <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h2><p>vector大部分方法都使用了synchronized修饰符，所以他是线层安全的集合类。</p><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出。</p><p>Stack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">empty()</span><br><span class="line"></span><br><span class="line">测试堆栈是否为空。</span><br><span class="line"></span><br><span class="line">peek()</span><br><span class="line"></span><br><span class="line">查看堆栈顶部的对象，但不从堆栈中移除它。</span><br><span class="line"></span><br><span class="line">pop()</span><br><span class="line"></span><br><span class="line">移除堆栈顶部的对象，并作为此函数的值返回该对象。</span><br><span class="line"></span><br><span class="line">push(E item)</span><br><span class="line"></span><br><span class="line">把项压入堆栈顶部。</span><br><span class="line"></span><br><span class="line">search(Object o)</span><br><span class="line"></span><br><span class="line">返回对象在堆栈中的位置，以 <span class="number">1</span> 为基数。</span><br></pre></td></tr></table></figure></p><p>Stack继承Vector，他对Vector进行了简单的扩展：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> <span class="keyword">extends</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class"><span class="title">Stack</span>的实现非常简单，仅有一个构造方法，五个实现方法（从<span class="title">Vector</span>继承而来的方法不算与其中），同时其实现的源码非常简单</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * 构造函数</span></span><br><span class="line"><span class="class"> */</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Stack</span>() </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  push函数：将元素存入栈顶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">     将元素存入栈顶。</span><br><span class="line">     addElement()的实现在Vector.java中</span><br><span class="line">    addElement(item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pop函数：返回栈顶元素，并将其从栈中删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E    obj;</span><br><span class="line">    <span class="keyword">int</span>    len = size();</span><br><span class="line"></span><br><span class="line">    obj = peek();</span><br><span class="line">     删除栈顶元素，removeElementAt()的实现在Vector.java中</span><br><span class="line">    removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * peek函数：返回栈顶元素，不执行删除操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>    len = size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">     返回栈顶元素，elementAt()具体实现在Vector.java中</span><br><span class="line">    <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  查找“元素o”在栈中的位置：由栈底向栈顶方向数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     获取元素索引，elementAt()具体实现在Vector.java中</span><br><span class="line">    <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Stack的源码很多都是基于Vector，所以这里不再累述</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>ArrayList的优缺点</p><p>从上面的几个过程总结一下ArrayList的优缺点。ArrayList的优点如下：</p><ol><li>ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快</li><li><p>ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已<br>不过ArrayList的缺点也十分明显：</p></li><li><p>删除元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p></li><li><p>插入元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p></li></ol><p>因此，ArrayList比较适合顺序添加、随机访问的场景。</p><p>ArrayList和Vector的区别<br>ArrayList是线程非安全的，这很明显，因为ArrayList中所有的方法都不是同步的，在并发下一定会出现线程安全问题。那么我们想要使用ArrayList并且让它线程安全怎么办？一个方法是用Collections.synchronizedList方法把你的ArrayList变成一个线程安全的List，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">"aaa"</span>);</span><br><span class="line">synchronizedList.add(<span class="string">"bbb"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; synchronizedList.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法就是Vector，它是ArrayList的线程安全版本，其实现90%和ArrayList都完全一样，区别在于：</p><ol><li><p>Vector是线程安全的，ArrayList是线程非安全的</p></li><li><p>Vector可以指定增长因子，如果该增长因子指定了，那么扩容的时候会每次新的数组大小会在原数组的大小基础上加上增长因子；如果不指定增长因子，那么就给原数组大小*2，源代码是这样的：<br> int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</p><pre><code>capacityIncrement : oldCapacity);</code></pre></li></ol><p>本文转载出处：<a href="https://h2pl.github.io/2018/05/08/collection1/" target="_blank" rel="noopener">h2pl</a></p>]]></content>
      
      
      <categories>
          
          <category> Java集合详解 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第四章——对象的组合</title>
      <link href="/2018/11/19/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/"/>
      <url>/2018/11/19/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>本章将介绍一些组合模式，这些模式能够使一个类更容易成为线程安全的，并且在维护这些类时不会无意破坏类的安全性保证。<br><a id="more"></a></p><h1 id="4-1-设计线程安全的类"><a href="#4-1-设计线程安全的类" class="headerlink" title="4.1 设计线程安全的类"></a>4.1 设计线程安全的类</h1><p>通过使用线程封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否时线程安全的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在设计线程安全类的过程中，需要包含以下三个基本要素：</span><br><span class="line">1. 找出构成对象状态的所有变量</span><br><span class="line">2. 找出约束状态变量的不可变条件</span><br><span class="line">3. 建立对象状态的并发访问管理策略</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Concurrency in Practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer</title>
      <link href="/2018/11/19/%E5%89%91%E6%8C%87offer/"/>
      <url>/2018/11/19/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<p>剑指offer的实现 参考文章<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md" target="_blank" rel="noopener">传送门</a><br><a id="more"></a><br><!-- GFM-TOC --></p><ul><li><a href="#1-数组中重复的数字">1. 数组中重复的数字</a></li><li><a href="#2-二维数组的查找">2. 二维数组中的查找</a></li><li><a href="#3-替换空格">3. 替换空格</a></li><li><a href="#4-从尾到头打印链表">4. 从尾到头打印链表</a></li><li><a href="#5-重建二叉树">5. 重建二叉树</a><!-- GFM-TOC --></li></ul><h1 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1. 数组中重复的数字"></a>1. 数组中重复的数字</h1><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;2, 3, 1, 0, 2, 5&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求复杂度为 O(N) + O(1)，也就是时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。牛客网讨论区这一题的首票答案使用 nums[i] + length 来将元素标记，这么做会有加法溢出问题。</p><p>这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上。</p><p>以 (2, 3, 1, 0, 2, 5) 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position-0 : (2,3,1,0,2,5) // 2 &lt;-&gt; 1</span><br><span class="line">             (1,3,2,0,2,5) // 1 &lt;-&gt; 3</span><br><span class="line">             (3,1,2,0,2,5) // 3 &lt;-&gt; 0</span><br><span class="line">             (0,1,2,3,2,5) // already in position</span><br><span class="line">position-1 : (0,1,2,3,2,5) // already in position</span><br><span class="line">position-2 : (0,1,2,3,2,5) // already in position</span><br><span class="line">position-3 : (0,1,2,3,2,5) // already in position</span><br><span class="line">position-4 : (0,1,2,3,2,5) // nums[i] == nums[nums[i]], exit</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span>  <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i ,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-二维数组的查找"><a href="#2-二维数组的查找" class="headerlink" title="2. 二维数组的查找"></a>2. 二维数组的查找</h1><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="直接暴力-复杂度O-n-2-O-1"><a href="#直接暴力-复杂度O-n-2-O-1" class="headerlink" title="直接暴力 复杂度O(n^2) + O(1)"></a>直接暴力 复杂度O(n^2) + O(1)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。"><a href="#因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。" class="headerlink" title="因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。"></a>因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span> || array == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = array.length , cols = array[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; row &amp;&amp; c &gt;=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[r][c] == target) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[r][c] &gt; target) c--;</span><br><span class="line">        <span class="keyword">else</span> r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3. 替换空格"></a>3. 替换空格</h1><p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串中的空格替换成 “%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;We Are Happy&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;We%20Are%20Happy&quot;</span><br></pre></td></tr></table></figure><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接暴力如果是空格则添加不是则保留 复杂度O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    StringBuilder newStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">            newStr.append(<span class="string">'%'</span>);</span><br><span class="line">            newStr.append(<span class="string">'2'</span>);</span><br><span class="line">            newStr.append(<span class="string">'0'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newStr.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-从尾到头打印链表"><a href="#4-从尾到头打印链表" class="headerlink" title="4. 从尾到头打印链表"></a>4. 从尾到头打印链表</h1><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入链表的第一个节点，从尾到头反过来打印出每个结点的值。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-使用栈"><a href="#1-使用栈" class="headerlink" title="(1)使用栈"></a>(1)使用栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123; </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        list.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### (2)使用递归</span><br><span class="line">```java</span><br><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123; </span><br><span class="line">    ArrayList&lt;Integr&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">        list.add(listNode.val);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第三章——对象的共享</title>
      <link href="/2018/11/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/"/>
      <url>/2018/11/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>第二章的开头曾指出，要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要正确的管理。第二章介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据，而本章将介绍如何共享和发布对象，从而是他们能够安全地由多个线程同时访问。<br><a id="more"></a></p><h1 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h1><p>可见性是一种复杂的属性， 因为可见性中的错误总会违背我们的直觉。为了确保线程之间对内存的写入操作的可见性，必须使用同步机制。</p><pre><code>public class NoVisibility {    private static boolean ready;    private static int number;    private static class ReaderThread extends Thread {        @Override        public void run() {            while(!ready) {                Thread.yield();                System.out.println(number);            }        }    }    public static void main(String[] args) {        new ReaderThead().start();        number = 42;        ready = true;    }</code></pre><p>}</p><h2 id="3-1-1-失效数据"><a href="#3-1-1-失效数据" class="headerlink" title="3.1.1 失效数据"></a>3.1.1 失效数据</h2><p>Novisibility中展示了在缺乏同步的程序中可能产生错误结果的一种情况：失效数据源。</p><h2 id="3-1-2-非原子的64位操作"><a href="#3-1-2-非原子的64位操作" class="headerlink" title="3.1.2 非原子的64位操作"></a>3.1.2 非原子的64位操作</h2><p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性也被称为最低安全性。</p><p>最低安全性适用于绝大多数的变量，但是有一个例外：非volatile类型的64位的数值变量(double、long)。对于非volatile类型的long和double变量的读取和写入是非原子的。</p><h2 id="3-1-3-加锁与可见性"><a href="#3-1-3-加锁与可见性" class="headerlink" title="3.1.3 加锁与可见性"></a>3.1.3 加锁与可见性</h2><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能够看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在一个锁上进行同步。</p><h2 id="3-1-4-volatile变量"><a href="#3-1-4-volatile变量" class="headerlink" title="3.1.4 volatile变量"></a>3.1.4 volatile变量</h2><p>在访问volatile变量时不会执行加锁操作，因此也就不会执行线程阻塞，因此volatile时是一种比synchronized关键字更轻量的同步机制。</p><p>volatile变量通常用作标志位，标识状态的改变。但是volatile的语义不足以确保递增操作(count++)的原子性，原子变量提供了”读-改-写”的原子操作，常常用作一种更好的”volatile”变量。</p><p>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。</p><h1 id="3-2-发布与溢出"><a href="#3-2-发布与溢出" class="headerlink" title="3.2 发布与溢出"></a>3.2 发布与溢出</h1><p>“发布”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布改对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就称为溢出。</p><p>对于类中外部方法(既不是私有的方法也不是终结final方法)，当把一个对象传递给某个外部方法，就相当于发布了这个对象。</p><p>this引用溢出的详细介绍：<a href="https://blog.csdn.net/flysqrlboy/article/details/10607295" target="_blank" rel="noopener">传送门</a></p><h1 id="3-3-线程封闭"><a href="#3-3-线程封闭" class="headerlink" title="3.3 线程封闭"></a>3.3 线程封闭</h1><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术称为线程封闭，它是实现线程安全性的最简单方式之一</p><h2 id="3-3-1-Ad-hoc线程封闭"><a href="#3-3-1-Ad-hoc线程封闭" class="headerlink" title="3.3.1 Ad-hoc线程封闭"></a>3.3.1 Ad-hoc线程封闭</h2><p>Ad-hoc线程封闭是指，维护线程的封闭性的职责完全由程序实现来承担。不推荐使用</p><h2 id="3-3-2-栈封闭"><a href="#3-3-2-栈封闭" class="headerlink" title="3.3.2 栈封闭"></a>3.3.2 栈封闭</h2><p>栈封闭是线程封闭的一种特列，在栈封闭中，只有通过局部变量才能访问对象。</p><h2 id="3-3-3-ThreadLocal类-看源码"><a href="#3-3-3-ThreadLocal类-看源码" class="headerlink" title="3.3.3 ThreadLocal类(看源码)"></a>3.3.3 ThreadLocal类(看源码)</h2><p>使用线程封闭的一种更规范的方法是ThreadLocal，这个类能使线程的某个值与保存值得对象关联起来。ThreadLocal提供了get和set等访问接口的方法，这些方法位每个使用该变量的线程都存有一份独立的副本，因此get方法总能返回由当前线在tiaoyongset设置的最新值。</p><p>ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。</p><h1 id="3-4-不变性"><a href="#3-4-不变性" class="headerlink" title="3.4 不变性"></a>3.4 不变性</h1><p>满足同步需求的另一种方法是使用不可变对象。如果某个对象在被创建以后其状态不可改变，那么这个对象就被称为不可变对象。不可变对象一定线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> Java 并发编程实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Concurrency in Practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java多线程 (二) ——创建与启动</title>
      <link href="/2018/11/15/java%E5%A4%9A%E7%BA%BF%E7%A8%8B2-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
      <url>/2018/11/15/java%E5%A4%9A%E7%BA%BF%E7%A8%8B2-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>一、定义线程<br>1、扩展java.lang.Thread类</p><p>此类中有个run()方法，应该注意其用法：</p><pre><code>public void run()如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。Thread 的子类应该重写该方法。</code></pre><a id="more"></a><p>2、实现java.lang.Runnable接口</p><pre><code>void run()使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run 方法。方法 run 的常规协定是，它可能执行任何所需的操作。</code></pre><p>二、实例化线程</p><pre><code>1、如果是扩展java.lang.Thread类的线程，则直接new即可。2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法：Thread(Runnable target)Thread(Runnable target, String name)Thread(ThreadGroup group, Runnable target)Thread(ThreadGroup group, Runnable target, String name)Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code></pre><p>三、启动线程</p><p>在线程的Thread对象上调用start()方法，而不是run()或者别的方法。</p><p>在调用start()方法之前：线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。</p><p>在调用start()方法之后：发生了一系列复杂的事情</p><p>启动新的执行线程（具有新的调用栈）；</p><p>该线程从新状态转移到可运行状态；</p><p>当该线程获得机会执行时，其目标run()方法将运行。</p><p>注意：对Java来说，run()方法没有任何特别之处。像main()方法一样，它只是新线程知道调用的方法名称(和签名)。因此，在Runnable上或者Thread上调用run方法是合法的。但并不启动新的线程。<br>四、例子<br>1、实现Runnable接口的多线程例子</p><pre><code>/** * 实现Runnable接口的类 * * @author leizhimin 2008-9-13 18:12:10 */     public class DoSomething implements Runnable {         private String name;     public DoSomething(String name) {         this.name = name;     }     public void run() {      for (int i = 0; i &lt; 5; i++) {         for (long k = 0; k &lt; 100000000; k++) ;         System.out.println(name + &quot;: &quot; + i);     } } }/** * 测试Runnable类实现的多线程程序 * * @author leizhimin 2008-9-13 18:15:02 */ public class TestRunnable {     public static void main(String[] args) {         DoSomething ds1 = new DoSomething(&quot;阿三&quot;);         DoSomething ds2 = new DoSomething(&quot;李四&quot;);         Thread t1 = new Thread(ds1);         Thread t2 = new Thread(ds2);         t1.start();         t2.start();     } }</code></pre><p>执行结果：</p><p>李四: 0<br>阿三: 0<br>李四: 1<br>阿三: 1<br>李四: 2<br>李四: 3<br>阿三: 2<br>李四: 4<br>阿三: 3<br>阿三: 4<br>Process finished with exit code 0</p><p>2、扩展Thread类实现的多线程例子</p><pre><code>/** * 测试扩展Thread类实现的多线程程序 * * @author leizhimin 2008-9-13 18:22:13 */ public class TestThread extends Thread{     public TestThread(String name) {         super(name);     }     public void run() {         for(int i = 0;i&lt;5;i++){             for(long k= 0; k &lt;100000000;k++);             System.out.println(this.getName()+&quot; :&quot;+i);         }     }     public static void main(String[] args) {         Thread t1 = new TestThread(&quot;阿三&quot;);         Thread t2 = new TestThread(&quot;李四&quot;);         t1.start();         t2.start();     } }</code></pre><p>执行结果：</p><p>阿三 :0<br>李四 :0<br>阿三 :1<br>李四 :1<br>阿三 :2<br>李四 :2<br>阿三 :3<br>阿三 :4<br>李四 :3<br>李四 :4<br>Process finished with exit code 0</p><p>对于上面的多线程程序代码来说，输出的结果是不确定的。其中的一条语句for(long k= 0; k &lt;100000000;k++);是用来模拟一个非常耗时的操作的。<br>五、一些常见问题</p><p>1、线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。</p><p>2、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。</p><p>3、获取当前线程的对象的方法是：Thread.currentThread()；</p><p>4、在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。</p><p>5、当线程目标run()方法结束时该线程完成。</p><p>6、一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。</p><p>7、线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。</p><p>众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。</p><p>8、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列唱呢个一个队列的事实。</p><p>9、尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</p>]]></content>
      
      
      <categories>
          
          <category> java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -多线程 -并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java多线程 (一) ——概念和原理</title>
      <link href="/2018/11/13/java%E5%A4%9A%E7%BA%BF%E7%A8%8B1-%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2018/11/13/java%E5%A4%9A%E7%BA%BF%E7%A8%8B1-%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、操作系统中进程和线程的概念"><a href="#一、操作系统中进程和线程的概念" class="headerlink" title="一、操作系统中进程和线程的概念"></a>一、操作系统中进程和线程的概念</h1><p>现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。</p><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。<br><a id="more"></a><br>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。</p><p>“同时”执行是人的感觉，在线程之间实际上轮换执行。 </p><h1 id="二、Java中的线程"><a href="#二、Java中的线程" class="headerlink" title="二、Java中的线程"></a>二、Java中的线程</h1><p>在Java中，线程可以代指两件不同的事情</p><ol><li>java.lang.Thread 的一个实例</li><li>线程的运行</li></ol><p>java线程的基本知识:</p><p>使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。</p><p>一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。</p><p>Java中，每个线程都有一个调用栈。 </p><p>一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。</p><p>一旦创建一个新的线程，就产生一个新的调用栈。</p><p>线程总体分两类：用户线程和守护线程。</p><p>当所有用户线程执行完毕的时候，JVM自动关闭。但是守护线程却不独立于JVM，守护线程一般是由操作系统或者用户自己创建的。</p>]]></content>
      
      
      <categories>
          
          <category> java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leslie</title>
      <link href="/2018/11/09/leslie/"/>
      <url>/2018/11/09/leslie/</url>
      
        <content type="html"><![CDATA[<p>时间是个让人触不及防的东西，真的没想到我竟然快要毕业了，仿佛一切都还刚发生，好像我还是那个高考失败发誓要在大学里面好好学习的高中生，一切都好像历历在目。可是我好像又失败了，在大学也没好好学习。我还依稀记得我在高考失败信誓旦旦的说我一定会好好学习的，我也不知道多少个夜晚我都发誓说要好好学习，可第二天它就被我抛弃了。可是直到找工作的时候，我才明白自己的处境，知道自己是那么的不堪。“不优秀不可怕，可怕的是知道自己不优秀还不努力”这句话应该就是我真实的写照吧。</p><p>回首大学岁月，让我最后悔的就是放弃acm吧，让我现在离梦想那么远，跟别人差距那么大，我羡慕别人，可是发现这一切都是我应得的。你有多努力，就有多幸运。我倒下了。哦，对了，大学没谈一场轰天动地的恋爱也是很遗憾啊，也许这辈子就单身了。哈哈哈哈哈哈</p><p>奉劝各位还在读大学的象牙塔的学生们，该学习的时候一定好好学习，顺便谈一场属于自己的学生时代的恋爱。</p><pre><code>Hello World 不知道现在努力还来的及码？</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大学生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活感悟 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
