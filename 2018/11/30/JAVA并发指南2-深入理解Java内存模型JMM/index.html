<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="首页     本站原创     深入理解Java内存模型（一）——基础                      深入理解Java内存模型（一）——基础           本文属于作者原创，原文发表于InfoQ：http://www.infoq.com/cn/articles/java-memory-model-1并发编程模型的分类在并发编程中，我们需要处理两个">
<meta name="keywords" content="JAVA并发">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA并发指南2-深入理解Java内存模型JMM">
<meta property="og:url" content="https://soleslie.github.io/2018/11/30/JAVA并发指南2-深入理解Java内存模型JMM/index.html">
<meta property="og:site_name" content="leslie的博客">
<meta property="og:description" content="首页     本站原创     深入理解Java内存模型（一）——基础                      深入理解Java内存模型（一）——基础           本文属于作者原创，原文发表于InfoQ：http://www.infoq.com/cn/articles/java-memory-model-1并发编程模型的分类在并发编程中，我们需要处理两个">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ifeve.com/wp-content/uploads/2013/01/113.png">
<meta property="og:image" content="http://ifeve.com/wp-content/uploads/2013/01/221.png">
<meta property="og:image" content="http://ifeve.com/wp-content/uploads/2013/01/331.png">
<meta property="og:image" content="http://ifeve.com/wp-content/uploads/2013/01/441.png">
<meta property="og:image" content="http://ifeve.com/wp-content/uploads/2013/01/552.png">
<meta property="og:image" content="http://ifeve.com/wp-content/uploads/2018/09/cache-ads.png">
<meta property="og:image" content="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=80&d=mm&r=g">
<meta property="og:image" content="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=80&d=mm&r=g">
<meta property="og:image" content="http://ifeve.com/wp-content/plugins/wp-favorite-posts/img/star.png">
<meta property="og:image" content="http://ifeve.com/wp-content/plugins/wp-favorite-posts/img/loading.gif">
<meta property="og:image" content="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif">
<meta property="og:image" content="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif">
<meta property="og:image" content="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif">
<meta property="og:image" content="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif">
<meta property="og:image" content="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif">
<meta property="og:image" content="http://ifeve.com/wp-content/plugins/wp-postratings/images/loading.gif">
<meta property="og:image" content="http://0.gravatar.com/avatar/6b552991a41338e608a6aab63e35ccc1?s=35&d=mm&r=g">
<meta property="og:image" content="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=35&d=mm&r=g">
<meta property="og:image" content="http://0.gravatar.com/avatar/3ca86dfeb755d5f5b2c564d4efb7f093?s=35&d=mm&r=g">
<meta property="og:image" content="http://1.gravatar.com/avatar/a21e2b8f4893347e62eeca7597f04ebc?s=35&d=mm&r=g">
<meta property="og:image" content="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=35&d=mm&r=g">
<meta property="og:image" content="http://0.gravatar.com/avatar/04637b376a1a4f462b3d56c73a107b71?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/e5e9d003cdf6c5873b358793c24678e1?s=35&d=mm&r=g">
<meta property="og:image" content="http://1.gravatar.com/avatar/16b6a3995f98a244392797aa3b96f7c4?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/?s=35&d=mm&r=g">
<meta property="og:image" content="http://0.gravatar.com/avatar/f8f180bd8fdaef97302ac66fe6ddc657?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/270c6507031b43ad91f271738a285dbe?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/bce7ab478a04ba9f0471a5ad696152a0?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/270c6507031b43ad91f271738a285dbe?s=35&d=mm&r=g">
<meta property="og:image" content="http://0.gravatar.com/avatar/3e9cfde4c4636a286e572359813c6590?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/?s=35&d=mm&r=g">
<meta property="og:image" content="http://1.gravatar.com/avatar/?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/2d60f2d6206602ab9c6c9e68080152de?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/e5e9d003cdf6c5873b358793c24678e1?s=35&d=mm&r=g">
<meta property="og:image" content="http://0.gravatar.com/avatar/377074e437bb085138351770105e4e7b?s=35&d=mm&r=g">
<meta property="og:image" content="http://0.gravatar.com/avatar/ce3dfcb0a5bdd71725749f5173fca761?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/5e242d05d154f3fd67af55ea1ffdcb63?s=35&d=mm&r=g">
<meta property="og:image" content="http://0.gravatar.com/avatar/31a570190aeb6ba02bc18a4e3ab27b01?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/522b21477ce640652c9c8f9d805157ed?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/522b21477ce640652c9c8f9d805157ed?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/5f10998c4508557e26dd895a28458746?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/522b21477ce640652c9c8f9d805157ed?s=35&d=mm&r=g">
<meta property="og:image" content="http://1.gravatar.com/avatar/a1723e5d1d844c2c8a27b2627875f029?s=35&d=mm&r=g">
<meta property="og:image" content="http://2.gravatar.com/avatar/5d578df5ea608313f8e9cb25fc9fb424?s=35&d=mm&r=g">
<meta property="og:image" content="http://icon.cnzz.com/img/pic.gif">
<meta property="og:updated_time" content="2018-11-30T05:59:13.788Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JAVA并发指南2-深入理解Java内存模型JMM">
<meta name="twitter:description" content="首页     本站原创     深入理解Java内存模型（一）——基础                      深入理解Java内存模型（一）——基础           本文属于作者原创，原文发表于InfoQ：http://www.infoq.com/cn/articles/java-memory-model-1并发编程模型的分类在并发编程中，我们需要处理两个">
<meta name="twitter:image" content="http://ifeve.com/wp-content/uploads/2013/01/113.png">



  <link rel="alternate" href="/atom.xml" title="leslie的博客" type="application/atom+xml">




  <link rel="canonical" href="https://soleslie.github.io/2018/11/30/JAVA并发指南2-深入理解Java内存模型JMM/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JAVA并发指南2-深入理解Java内存模型JMM | leslie的博客</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">leslie的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">当你奋力前行时，全世界都会为你让路</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://soleslie.github.io/2018/11/30/JAVA并发指南2-深入理解Java内存模型JMM/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leslie的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JAVA并发指南2-深入理解Java内存模型JMM
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-30 13:51:04 / 修改时间：13:59:13" itemprop="dateCreated datePublished" datetime="2018-11-30T13:51:04+08:00">2018-11-30</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JAVA并发指南/" itemprop="url" rel="index"><span itemprop="name">JAVA并发指南</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <div id="main_content" class="clearfix"><br><br>  <div id="left_col"><br>      <div id="bread_crumb"><br>    <ul class="clearfix"><br>     <li id="bc_home"><a href="http://ifeve.com/" title="首页" target="_blank" rel="noopener">首页</a></li><br>     <li id="bc_cat"><a href="http://ifeve.com/category/talk-concurrent/" target="_blank" rel="noopener">本站原创</a></li>     <li class="last">深入理解Java内存模型（一）——基础</li><br>    </ul><br>   </div>


   <div class="post_wrap clearfix" id="single"><br>    <div class="post"><br>     <h3 class="title"><span>深入理解Java内存模型（一）——基础</span></h3><br>     <div class="post_content"><br>      <p>本文属于作者原创，原文发表于InfoQ：<a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank">http://www.infoq.com/cn/articles/java-memory-model-1</a></p><br><h1>并发编程模型的分类</h1><br><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。<br><br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。<br><br>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br><br>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。<br><br><span id="more-2167"></span></p><br><h1>Java内存模型的抽象</h1><br><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br><br>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：<br><br><a href="http://ifeve.com/wp-content/uploads/2013/01/113.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2273" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/113.png" width="423" height="377" srcset="http://ifeve.com/wp-content/uploads/2013/01/113.png 423w, http://ifeve.com/wp-content/uploads/2013/01/113-300x267.png 300w" sizes="(max-width: 423px) 100vw, 423px"></a><br><br>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：<br><br>1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br><br>2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。<br><br>下面通过示意图来说明这两个步骤：<br><br><a href="http://ifeve.com/wp-content/uploads/2013/01/221.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2275" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/221.png" width="440" height="334" srcset="http://ifeve.com/wp-content/uploads/2013/01/221.png 440w, http://ifeve.com/wp-content/uploads/2013/01/221-300x227.png 300w" sizes="(max-width: 440px) 100vw, 440px"></a><br><br>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br><br>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p><br><h1>重排序</h1><br><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：<br><br>1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br><br>2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br><br>3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br><br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><br><a href="http://ifeve.com/wp-content/uploads/2013/01/331.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2277" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/331.png" width="529" height="76" srcset="http://ifeve.com/wp-content/uploads/2013/01/331.png 529w, http://ifeve.com/wp-content/uploads/2013/01/331-300x43.png 300w" sizes="(max-width: 529px) 100vw, 529px"></a><br><br>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br><br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><br><h1>处理器重排序与内存屏障指令</h1><br><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p><br><table width="500" border="1"><br><tbody><br><tr><br><th>Processor A</th><br><th>Processor B</th><br></tr><br><tr><br><td>a = 1; //A1<br><br>x = b; //A2</td><br><td>b = 2; //B1<br><br>y = a; //B2</td><br></tr><br><tr><br><td colspan="2">初始状态：a = b = 0<br><br>处理器允许执行后得到结果：x = y = 0</td><br></tr><br></tbody><br></table><br><p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：<br><br><a href="http://ifeve.com/wp-content/uploads/2013/01/441.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2279" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/441.png" width="412" height="303" srcset="http://ifeve.com/wp-content/uploads/2013/01/441.png 412w, http://ifeve.com/wp-content/uploads/2013/01/441-300x220.png 300w" sizes="(max-width: 412px) 100vw, 412px"></a><br><br>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。<br><br>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。<br><br>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。<br><br>下面是常见处理器允许的重排序类型的列表：</p><br><table style="width: 514px;height: 127px" width="514" border="1"><br><tbody><br><tr><br><td>&nbsp;</td><br><td>Load-Load</td><br><td>Load-Store</td><br><td>Store-Store</td><br><td>Store-Load</td><br><td>数据依赖</td><br></tr><br><tr><br><td>sparc-TSO</td><br><td>N</td><br><td>N</td><br><td>N</td><br><td>Y</td><br><td>N</td><br></tr><br><tr><br><td>x86</td><br><td>N</td><br><td>N</td><br><td>N</td><br><td>Y</td><br><td>N</td><br></tr><br><tr><br><td>ia64</td><br><td>Y</td><br><td>Y</td><br><td>Y</td><br><td>Y</td><br><td>N</td><br></tr><br><tr><br><td>PowerPC</td><br><td>Y</td><br><td>Y</td><br><td>Y</td><br><td>Y</td><br><td>N</td><br></tr><br></tbody><br></table><br><p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。<br><br>从上表我们可以看出：常见的处理器都允许Store-Load重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。<br><br>※注1：sparc-TSO是指以TSO(Total Store Order)内存模型运行时，sparc处理器的特性。<br><br>※注2：上表中的x86包括x64及AMD64。<br><br>※注3：由于ARM处理器的内存模型与PowerPC处理器的内存模型非常类似，本文将忽略它。<br><br>※注4：数据依赖性后文会专门说明。</p><br><p>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p><br><table style="width: 519px;height: 298px" width="519" border="1"><br><tbody><br><tr><br><td>屏障类型</td><br><td>指令示例</td><br><td>说明</td><br></tr><br><tr><br><td>LoadLoad Barriers</td><br><td>Load1; LoadLoad; Load2</td><br><td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td><br></tr><br><tr><br><td>StoreStore Barriers</td><br><td>Store1; StoreStore; Store2</td><br><td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td><br></tr><br><tr><br><td>LoadStore Barriers</td><br><td>Load1; LoadStore; Store2</td><br><td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td><br></tr><br><tr><br><td>StoreLoad Barriers</td><br><td>Store1; StoreLoad; Load2</td><br><td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td><br></tr><br></tbody><br></table><br><p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><br><h1>happens-before</h1><br><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br><br>与程序员密切相关的happens-before规则如下：</p><br><ul><br><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><br><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><br><li>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</li><br><li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li><br></ul><br><p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before的定义很微妙，后文会具体说明happens-before为什么要这么定义。<br><br>happens-before与JMM的关系如下图所示：</p><br><p>&nbsp;<a href="http://ifeve.com/wp-content/uploads/2013/01/552.png" target="_blank" rel="noopener"><img class="alignnone size-full wp-image-2281" alt="" src="http://ifeve.com/wp-content/uploads/2013/01/552.png" width="511" height="396" srcset="http://ifeve.com/wp-content/uploads/2013/01/552.png 511w, http://ifeve.com/wp-content/uploads/2013/01/552-300x232.png 300w" sizes="(max-width: 511px) 100vw, 511px"></a><br><br>如上图所示，一个happens-before规则通常对应于多个编译器和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><br><h1>参考文献</h1><br><ol><br><li><a href="http://www.amazon.com/Programming-Language-Pragmatics-Third-Michael/dp/0123745144/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1347794595&amp;sr=1-1&amp;keywords=Michael+L.Scott" target="_blank" rel="noopener">Programming Language Pragmatics, Third Edition</a></li><br><li><a href="http://docs.oracle.com/javase/specs/jls/se5.0/jls3.pdf" target="_blank" rel="noopener">The Java Language Specification, Third Edition</a></li><br><li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">JSR-133: Java Memory Model and Thread Specification</a></li><br><li><a href="http://www.ibm.com/developerworks/java/library/j-jtp03304/index.html" target="_blank" rel="noopener">Java theory and practice: Fixing the Java Memory Model, Part 2</a></li><br><li><a href="http://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf" target="_blank" rel="noopener">Understanding POWER Multiprocessors</a></li><br><li><a href="http://www.amazon.com/Concurrent-Programming-Windows-Joe-Duffy/dp/032143482X/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1262571776&amp;sr=1-1" target="_blank" rel="noopener">Concurrent Programming on Windows</a></li><br><li><a href="http://www.amazon.com/Art-Multiprocessor-Programming-Maurice-Herlihy/dp/0123705916/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1248834374&amp;sr=1-1" target="_blank" rel="noopener">The Art of Multiprocessor Programming</a></li><br><li><a href="http://download.intel.com/products/processor/manual/253668.pdf" target="_blank" rel="noopener">Intel® 64 and IA-32 ArchitecturesvSoftware Developer’s Manual Volume 3A: System Programming Guide, Part 1</a></li><br><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">The JSR-133 Cookbook for Compiler Writers</a></li><br></ol><br><h1>关于作者</h1><br><p><strong>程晓明</strong>，Java软件工程师，国家认证的系统分析师、信息项目管理师。专注于并发编程。个人邮箱：<a href="mailto:asst2003@163.com" target="_blank" rel="noopener">asst2003@163.com</a>。</p><br><hr><br><div style="margin-top: 15px; font-style: italic"><br><p><strong>原创文章，转载请注明：</strong> 转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a><strong>本文链接地址:</strong> <a href="http://ifeve.com/java-memory-model-1/" target="_blank" rel="noopener">深入理解Java内存模型（一）——基础</a></p><br></div><br><p><a target="_blank" href="http://www.proxool.cn/"><img src="http://ifeve.com/wp-content/uploads/2018/09/cache-ads.png"><br><br></a></p><br><br>                         <div class="abh_box abh_box_down abh_box_"><ul class="abh_tabs"> <li class="abh_about abh_active"><a href="#abh_about">About</a></li> <li class="abh_posts"><a href="#abh_posts">Latest Posts</a></li></ul><div class="abh_tab_content"><section class="vcard abh_about_tab abh_tab" style="display:block"><div class="abh_image"><a href="http://ifeve.com/author/25622818/" class="url" title="程晓明" target="_blank" rel="noopener"><img alt="" src="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=80&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=160&amp;d=mm&amp;r=g 2x" class="avatar avatar-80 photo" height="80" width="80"></a></div><div class="abh_social"> </div><div class="abh_text"><h3 class="fn name"><a href="http://ifeve.com/author/25622818/" class="url" target="_blank" rel="noopener">程晓明</a></h3><div class="abh_job"></div><div class="description note abh_description">程晓明，Java软件工程师，专注于并发编程，就职于富士通南大。个人邮箱：<a href="mailto:asst2003@163.com" target="_blank" rel="noopener">asst2003@163.com</a>。</div></div> </section><section class="abh_posts_tab abh_tab"><div class="abh_image"><a href="http://ifeve.com/author/25622818/" class="url" title="程晓明" target="_blank" rel="noopener"><img alt="" src="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=80&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=160&amp;d=mm&amp;r=g 2x" class="avatar avatar-80 photo" height="80" width="80"></a></div><div class="abh_social"> </div><div class="abh_text"><h4>Latest posts by 程晓明 <span class="abh_allposts">(<a href="http://ifeve.com/author/25622818/" target="_blank" rel="noopener">see all</a>)</span></h4><div class="abh_description note"><ul>                <li>                    <a href="http://ifeve.com/double-checked-locking-with-delay-initialization/" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a><span> - 2013年10月10日</span>                </li>               <li>                    <a href="http://ifeve.com/java-memory-model-7/" target="_blank" rel="noopener">深入理解Java内存模型（七）——总结</a><span> - 2013年3月16日</span>               </li>               <li>                    <a href="http://ifeve.com/java-memory-model/" target="_blank" rel="noopener">深入理解Java内存模型（六）——final</a><span> - 2013年3月10日</span>              </li></ul></div></div> </section></div> </div><span class="wpfp-span"><img src="http://ifeve.com/wp-content/plugins/wp-favorite-posts/img/star.png" alt="Favorite" title="Favorite" class="wpfp-img"><img src="http://ifeve.com/wp-content/plugins/wp-favorite-posts/img/loading.gif" alt="Loading" title="Loading" class="wpfp-hide wpfp-img"><a class="wpfp-link" href="?wpfpaction=add&amp;postid=2167" title="添加本文到我的收藏" rel="nofollow">添加本文到我的收藏</a></span><div class="yarpp-related"><br><h3>Related posts:</h3><ol><br><li><a href="http://ifeve.com/java-memory-model-7/" rel="noopener" title="深入理解Java内存模型（七）——总结" target="_blank">深入理解Java内存模型（七）——总结 </a></li><br><li><a href="http://ifeve.com/java-memory-model-2/" rel="noopener" title="深入理解Java内存模型（二）——重排序" target="_blank">深入理解Java内存模型（二）——重排序 </a></li><br><li><a href="http://ifeve.com/java-memory-model-5/" rel="noopener" title="深入理解Java内存模型（五）——锁" target="_blank">深入理解Java内存模型（五）——锁 </a></li><br><li><a href="http://ifeve.com/java-memory-model-3/" rel="noopener" title="深入理解Java内存模型（三）——顺序一致性" target="_blank">深入理解Java内存模型（三）——顺序一致性 </a></li><br><li><a href="http://ifeve.com/java-memory-model-4/" rel="noopener" title="深入理解Java内存模型（四）——volatile" target="_blank">深入理解Java内存模型（四）——volatile </a></li><br><li><a href="http://ifeve.com/java-memory-model/" rel="noopener" title="深入理解Java内存模型（六）——final" target="_blank">深入理解Java内存模型（六）——final </a></li><br><li><a href="http://ifeve.com/java-memory-model-0/" rel="noopener" title="深入理解java内存模型系列文章" target="_blank">深入理解java内存模型系列文章 </a></li><br><li><a href="http://ifeve.com/jmm-cookbook-mb/" rel="noopener" title="Java内存模型Cookbook（二）内存屏障" target="_blank">Java内存模型Cookbook（二）内存屏障 </a></li><br><li><a href="http://ifeve.com/memory-barriersfences/" rel="noopener" title="Memory Barriers/Fences" target="_blank">Memory Barriers/Fences </a></li><br><li><a href="http://ifeve.com/jmm-cookbook-mps/" rel="noopener" title="Java内存模型Cookbook(三)多处理器" target="_blank">Java内存模型Cookbook(三)多处理器 </a></li><br><li><a href="http://ifeve.com/cookbook-recipes/" rel="noopener" title="Java内存模型Cookbook（四）指南(Recipes)" target="_blank">Java内存模型Cookbook（四）指南(Recipes) </a></li><br><li><a href="http://ifeve.com/how-to-use-volatile/" rel="noopener" title="Java并发中正确使用volatile" target="_blank">Java并发中正确使用volatile </a></li><br><li><a href="http://ifeve.com/talk-to-my-understanding-of-the-java-memory-model/" rel="noopener" title="聊聊我对Java内存模型的理解" target="_blank">聊聊我对Java内存模型的理解 </a></li><br><li><a href="http://ifeve.com/jsr133/" rel="noopener" title="Java内存模型FAQ（三）JSR133是什么？" target="_blank">Java内存模型FAQ（三）JSR133是什么？ </a></li><br><li><a href="http://ifeve.com/paper-set/" rel="noopener" title="并发网系列文章集" target="_blank">并发网系列文章集 </a></li><br></ol><br></div><br>           </div><!-- END .post_content --><br>    </div><br>    <div class="meta"><br>          <ul><br>      <li class="post_date clearfix"><br>       <span class="date">24</span><br>       <span class="month">Jan</span><br>       <span class="year">2013</span><br>      </li><br><br><li class="post_comment"><br>66,367 人阅读</li><br><br>      <li class="post_author"><a href="http://ifeve.com/author/25622818/" title="由程晓明发布" rel="noopener" target="_blank">程晓明</a></li>      <li class="post_category"><a href="http://ifeve.com/category/talk-concurrent/" rel="noopener" target="_blank">本站原创</a></li>       <li class="post_category"><div id="post-ratings-2167" class="post-ratings" itemscope="" itemtype="http://schema.org/Article" data-nonce="ef26f95a4d"><img id="rating_2167_1" src="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif" alt="好烂啊" title="好烂啊" onmouseover="current_rating(2167, 1, '好烂啊');" onmouseout="ratings_off(4.7, 5, 0);" onclick="rate_post();" onkeypress="rate_post();" style="cursor: pointer; border: 0px;"><img id="rating_2167_2" src="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif" alt="没价值" title="没价值" onmouseover="current_rating(2167, 2, '没价值');" onmouseout="ratings_off(4.7, 5, 0);" onclick="rate_post();" onkeypress="rate_post();" style="cursor: pointer; border: 0px;"><img id="rating_2167_3" src="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif" alt="凑合看看" title="凑合看看" onmouseover="current_rating(2167, 3, '凑合看看');" onmouseout="ratings_off(4.7, 5, 0);" onclick="rate_post();" onkeypress="rate_post();" style="cursor: pointer; border: 0px;"><img id="rating_2167_4" src="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif" alt="还不错" title="还不错" onmouseover="current_rating(2167, 4, '还不错');" onmouseout="ratings_off(4.7, 5, 0);" onclick="rate_post();" onkeypress="rate_post();" style="cursor: pointer; border: 0px;"><img id="rating_2167_5" src="http://ifeve.com/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif" alt="超赞" title="超赞" onmouseover="current_rating(2167, 5, '超赞');" onmouseout="ratings_off(4.7, 5, 0);" onclick="rate_post();" onkeypress="rate_post();" style="cursor: pointer; border: 0px;"> (<strong>31</strong> votes, average: <strong>4.74</strong> out of 5)<br><span class="post-ratings-text" id="ratings_2167_text"></span><meta itemprop="headline" content="深入理解Java内存模型（一）——基础"><meta itemprop="description" content="本文属于作者原创，原文发表于InfoQ：http://www.infoq.com/cn/articles/java-memory-model-1
并发编程模型的分类
在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。
在共享内存的并..."><meta itemprop="datePublished" content="2013-01-24T00:03:00+00:00"><meta itemprop="dateModified" content="2013-01-28T08:45:32+00:00"><meta itemprop="url" content="http://ifeve.com/java-memory-model-1/"><meta itemprop="author" content="程晓明"><meta itemprop="mainEntityOfPage" content="http://ifeve.com/java-memory-model-1/"><div style="display: none;" itemprop="publisher" itemscope="" itemtype="https://schema.org/Organization"><meta itemprop="name" content="并发编程网 - ifeve.com"><div itemprop="logo" itemscope="" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content=""></div></div><div style="display: none;" itemprop="aggregateRating" itemscope="" itemtype="http://schema.org/AggregateRating"><meta itemprop="bestRating" content="5"><meta itemprop="worstRating" content="1"><meta itemprop="ratingValue" content="4.74"><meta itemprop="ratingCount" content="31"></div></div><div id="post-ratings-2167-loading" class="post-ratings-loading"><br>            <img src="http://ifeve.com/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image">Loading…</div></li>       <li class="post_comment"><a href="http://ifeve.com/java-memory-model-1/#comments" target="_blank" rel="noopener">30 条评论</a></li>           </ul><br>         </div><br>   </div><!-- END .post_wrap --><br><br><br>      <div id="comments_wrapper"><br><br><br><br><br><br><div id="comment_header" class="clearfix"><br><br> <ul id="comment_header_left"><br>  <li id="add_comment"><a href="#respond">发表评论</a></li><br>  <li id="comment_feed"><a href="http://ifeve.com/comments/feed/" title="RSS订阅评论" target="_blank" rel="noopener">RSS订阅评论</a></li><br> </ul><br><br> <ul id="comment_header_right"><br>   <li id="trackback_closed">Trackback 关闭</li><br>   <li id="comment_closed">评论 (30)</li><br> </ul><br><br><br></div><!-- END #comment_header --><br><br><div id="comments"><br><br> <div id="comment_area"><br>  <!-- start commnet --><br>  <ol class="commentlist"><br><br> <li class="comment guest-comment even_comment" id="comment-173"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://0.gravatar.com/avatar/6b552991a41338e608a6aab63e35ccc1?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/6b552991a41338e608a6aab63e35ccc1?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-173"><br><br>nicky<br></span><br>     </li><br>     <li class="comment-date">2013/01/28 3:25下午</li><br>    </ul><br>   </div>

   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-173', 'comment-173', 'comment-content-173', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-173"><br>    <p>你好，作为一名刚入行的程序员来说，看你这篇文章其实挺吃力的，特别是重排序那块，整个文章读下来的感觉，线程之间的通信和svn的使用相差不多，但是不知道，在2个线程之间发生 所谓的“冲突” 该如何处理，就像你描述在例子中 x=y=0的 ，你还是没有将如何操作才能得到我们所想要的结果呢，根据happens-before 这样的原则么，这个是不是和svn解决冲突是相类似的呢？</p><br>  </div><p></p>
<ul class="children"><br><br> <li class="comment admin-comment even_comment_children" id="comment-181"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=35&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-181"><br><br>程晓明<br></span><br>     </li><br>     <li class="comment-date">2013/01/29 8:23上午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-181', 'comment-181', 'comment-content-181', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-181"><br>    <p>您好，谢谢您的关注。<br><br>在第二篇中专门讲了重排序，，这一篇已经在本站发布了。<br><br>您说的“冲突”，在java内存模型中称之为“数据竞争”。<br><br>对于多线程之间的数据竞争，只要我们正确使用同步原语（lock, volatile和final），那么java内存模型就会对有冲突的操作进行排序。这样就能得到我们想要的结果。第三篇会专门讲这个主题。</p><br>  </div><p></p>
<p></p></li><!-- #comment-## --><br></ul><!-- .children --><br></li><!-- #comment-## --><p></p>
<p> <li class="comment guest-comment odd_comment" id="comment-344"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://0.gravatar.com/avatar/3ca86dfeb755d5f5b2c564d4efb7f093?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/3ca86dfeb755d5f5b2c564d4efb7f093?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-344"></span></li></ul></div></div></li></p>
<p>黑皮爷爷猪<br><br>     <br>     <li class="comment-date">2013/02/27 3:03下午</li><br>    <br>   </p></ol></div><p></p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-344', 'comment-344', 'comment-content-344', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-344"><br>    <p>您好，看了您很多并发方面的文章感觉受益很多。</p><p></p>
<p></p><p>在原来看并发时一直有一个疑问就是happens-before是谁来保证的呢？是我们在开发过程中需要注意的地方？还是JVM中的一些策略呢？也可以说是：是不是在开发中不需要关注happens-before原则呢？<br><br>因为比如：程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。这种规则是我们在写代码的过程中是无法保证的，只能是JVM来保证。<br><br>请问happens-before到底是JVM中的一种策略还是我们在编写代码中需要注意的地方？</p><br>  </div><p></p>
<ul class="children"><br><br> <li class="comment guest-comment odd_comment_children" id="comment-350"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://1.gravatar.com/avatar/a21e2b8f4893347e62eeca7597f04ebc?s=35&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/a21e2b8f4893347e62eeca7597f04ebc?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><a id="commentauthor-350" class="url guest-url" href="http://ifeve.com" rel="noopener" target="_blank"><br><br>方 腾飞<br></a><br>     </li><br>     <li class="comment-date">2013/02/27 5:38下午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-350', 'comment-350', 'comment-content-350', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-350"><br>    <p>happens-before是我们在编写代码中需要注意的口诀。</p><br>  </div><p></p>
<p></p></li><!-- #comment-## --><p></p>
<p> <li class="comment admin-comment odd_comment_children" id="comment-354"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=35&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/a05f28ab611e7a6d32ae4eef77d69f79?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-354"></span></li></ul></div></div></li></p>
<p>程晓明<br><br>     <br>     <li class="comment-date">2013/02/28 12:38上午</li><br>    </p></ul><br>   </div><p></p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-354', 'comment-354', 'comment-content-354', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-354"><br>    <p>谢谢您的关注。</p><p></p>
<p></p><p>腾飞的回答很简洁，也很精辟。</p><p></p>
<p></p><p>–happens-before是谁来保证的呢？<br><br>java内存模型通过限制编译器和处理器的重排序，来向程序员作出的内存可见性保证。</p><p></p>
<p></p><p>–程序顺序规则<br><br>程序顺序规则有两个作用：<br><br>1：java内存模型通过这个规则，可以向程序员保证：单线程内不会出现内存可见性问题（因为在程序顺序中的每个操作，都happens-before于它后面的操作）。<br><br>2：程序顺序规则与其他规则组合后，可以提供“额外”的保证。<br><br>比如在本文的第三章中的“volatile的写-读建立的happens before关系”这一节中，程序顺序规则与volatile规则及传递性规则三者组合后，可以保证：一个线程在写volatile变量之前可见的所有共享变量，在接下来另一个线程读同一个volatile变量后，将立即变得对这个线程可见。</p><p></p>
<p></p><p>happens-before的主要作用在于：向程序员保证不同线程的操作之间的内存可见性。<br><br>比如：假设A线程中有一个操作a，B线程中有一个操作b，如果a，b之间具有happens-before关系，那么java内存模型将向程序员保证：a操作的执行结果，b一定能看到。</p><br>  </div><p></p>
<ul class="children"><br><br> <li class="comment guest-comment even_comment_children" id="comment-9869"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://0.gravatar.com/avatar/04637b376a1a4f462b3d56c73a107b71?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/04637b376a1a4f462b3d56c73a107b71?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-9869"><br><br>草戊<br></span><br>     </li><br>     <li class="comment-date">2014/04/11 9:32上午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-9869', 'comment-9869', 'comment-content-9869', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-9869"><br>    <p>恍然大悟啊。看《java并发编程实战》那本书中，最不能明白的就是JMM中 【程序顺序规则】，<br><br>按照我的思维总觉得这个和指令重排序是矛盾的。看了这篇文章才明白。<br><br>太感谢了。</p><br>  </div><p></p>
<ul class="children"><br><br> <li class="comment guest-comment odd_comment_children" id="comment-26967"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/e5e9d003cdf6c5873b358793c24678e1?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/e5e9d003cdf6c5873b358793c24678e1?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-26967"><br><br>ericzou<br></span><br>     </li><br>     <li class="comment-date">2016/06/08 11:44上午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-26967', 'comment-26967', 'comment-content-26967', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-26967"><br>    <p>对这一块好像理解了，又好像没理解，看@草戊说理解了这块内容，@草戊,留个QQ或微信给我？想和你探讨一下</p><br>  </div><p></p>
<p></p></li><!-- #comment-## --><br></ul><!-- .children --><br></li><!-- #comment-## --><br></ul><!-- .children --><br><!-- #comment-## --><br><!-- .children --><br><!-- #comment-## --><p></p>
<p> <li class="comment guest-comment even_comment" id="comment-967"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://1.gravatar.com/avatar/16b6a3995f98a244392797aa3b96f7c4?s=35&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/16b6a3995f98a244392797aa3b96f7c4?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><a id="commentauthor-967" class="url guest-url" href="http://cnblogs.com/frydsh" rel="noopener" target="_blank"></a></li></ul></div></div></li></p>
<p>frydsh<br><br>     <br>     <li class="comment-date">2013/04/20 1:41上午</li><br>    <br>   </p></div><p></p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-967', 'comment-967', 'comment-content-967', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-967"><br>    <p>你好，看完之后豁然开朗。不过还是有两个疑问：<br><br>1.两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！<br><br>这句话是什么意思，感觉跟happen-before有冲突的样子，不是很理解。<br><br>2.一个线程在写volatile变量之前可见的所有共享变量，在接下来另一个线程读同一个volatile变量后，将立即变得对这个线程可见。<br><br>这个是volatile必然有的保障吗，JMM可以确保这个保障吗，还是一般实现支持它，但是JMM标准对它却没有定义？</p><br>  </div></p>
<ul class="children"><br><br> <li class="comment guest-comment even_comment_children" id="comment-971"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo avatar-default" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-971"><br><br>程晓明<br></span><br>     </li><br>     <li class="comment-date">2013/04/20 8:01下午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-971', 'comment-971', 'comment-content-971', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-971"><br>    <p>1：<br><br>在《深入理解Java内存模型（二）——重排序》的“程序顺序规则”，和《深入理解Java内存模型（七）——总结》的“JMM的设计”中，对这个这个问题有说明，可以参考。<br><br>java内存模型向程序员保证：如果A happens-before B，那么A操作的结果将对B可见，且A的执行顺序排在B之前。<br><br>注意，这仅仅是java内存模型向程序员做出的保证！如果重排序A和B的执行顺序后，程序的结果不被改变，那么java内存模型就允许编译器和处理器对这两个操作重排序。<br><br>这么做的原因是因为：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。<br><br>因此，happens-before关系本质上和as-if-serial语义是一回事！<br><br>as-if-serial语义保证单线程内程序的执行结果不被改变；<br><br>happens-before关系保证正确同步的多线程程序的执行结果不被改变。<br><br>as-if-serial语义给编写单线程程序的程序员创建了一个幻境：单线程程序是按程序的顺序来执行的。<br><br>happens-before关系给编写正确同步的多线程程序的程序员创建了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。<br><br>as-if-serial语义和happens-before关系这么做的目的是为了尽可能的开发并行度。<br><br>————————————<br><br>2：<br><br>从JDK5开始，这是volatile必然有的保障。<br><br>这是JMM规范的要求，所有的java实现都必须支持它。</p><br>  </div><p></p>
<ul class="children"><br><br> <li class="comment guest-comment odd_comment_children" id="comment-27980"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://0.gravatar.com/avatar/f8f180bd8fdaef97302ac66fe6ddc657?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/f8f180bd8fdaef97302ac66fe6ddc657?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-27980"><br><br>c340c340<br></span><br>     </li><br>     <li class="comment-date">2017/10/12 5:09下午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-27980', 'comment-27980', 'comment-content-27980', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-27980"><br>    <p>我觉得在这边要说明清楚的是所指的顺序是什么？操作发生的实现顺序，程序顺序，还是指令真正的执行顺序</p><br>  </div><p></p>
<p></p></li><!-- #comment-## --><br></ul><!-- .children --><br></li><!-- #comment-## --><br></ul><!-- .children --><br><!-- #comment-## --><p></p>
<p> <li class="comment guest-comment odd_comment" id="comment-1046"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/270c6507031b43ad91f271738a285dbe?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/270c6507031b43ad91f271738a285dbe?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><a id="commentauthor-1046" class="url guest-url" href="http://blueswind8306.iteye.com" rel="noopener" target="_blank"></a></li></ul></div></div></li></p>
<p>高 嵩<br><br>     <br>     <li class="comment-date">2013/05/01 6:17下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-1046', 'comment-1046', 'comment-content-1046', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-1046"><br>    <p>您好，请问一下，关于重排序的那个例子，我写了代码验证，在反复执行100w次的情况下，都没有出现x=y=0的结果，难道是因为很难出现这种情况吗？我的代码如下：<br><br>public class TestReordering {</p></div></p>
<p></p><p> private int a = 0;<br><br>    private int b = 0;</p><p></p>
<p></p><p> private class ThreadATask implements Runnable {<br><br>        private int x;</p><p></p>
<p></p><p>     public void run() {<br><br>            a = 1;  // A1<br><br>            x = b;  // A2<br><br>        }</p><p></p>
<p></p><p>     public int getX() {<br><br>            return x;<br><br>        }<br><br>    }</p><p></p>
<p></p><p> private class ThreadBTask implements Runnable {<br><br>        private int y;</p><p></p>
<p></p><p>     public void run() {<br><br>            b = 2;  // B1<br><br>            y = a;  // B2<br><br>        }</p><p></p>
<p></p><p>     public int getY() {<br><br>            return y;<br><br>        }<br><br>    }</p><p></p>
<p></p><p> public String doTest() throws InterruptedException {<br><br>        ThreadATask taskA = new ThreadATask();<br><br>        ThreadBTask taskB = new ThreadBTask();<br><br>        Thread threadA = new Thread(taskA);<br><br>        Thread threadB = new Thread(taskB);     </p><p></p>
<p></p><p>     threadA.start();<br><br>        threadB.start();</p><p></p>
<p></p><p>     threadA.join();<br><br>        threadB.join();</p><p></p>
<p></p><p>     return “x=” + taskA.getX() + “, y=” + taskB.getY();<br><br>    }</p><p></p>
<p></p><p> /**<br></p>
<pre><code> * @param args&lt;br&gt;
 * @throws InterruptedException&lt;br&gt;
 */&lt;br&gt;
public static void main(String[] args) throws InterruptedException {&lt;br&gt;
    Map counter = new HashMap();&lt;/p&gt;
</code></pre><p></p><p>     for (int i = 0; i &lt; Integer.parseInt(args[0]); i++) {<br><br>            TestReordering test = new TestReordering();<br><br>            String result = test.doTest();</p><p></p>
<p></p><p>         Integer count = counter.get(result);<br><br>            if (count == null) {<br><br>                count = 0;<br><br>            }<br><br>            counter.put(result, count.intValue() + 1);<br><br>        }</p><p></p>
<p></p><p>     for (String result : counter.keySet()) {<br><br>            System.out.println(result + “, count=” + counter.get(result));<br><br>        }<br><br>    }</p><p></p>
<p></p><p>}</p><br>  <p></p>
<ul class="children"><br><br> <li class="comment guest-comment odd_comment_children" id="comment-1063"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/?s=35&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo avatar-default" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-1063"><br><br>程晓明<br></span><br>     </li><br>     <li class="comment-date">2013/05/04 4:32下午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-1063', 'comment-1063', 'comment-content-1063', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-1063"><br>    <p>你需要创造条件让两个线程尽可能的在同一时间点执行执行，才可能出现出现x=y=0的结果。<br><br>我稍微修改了一下你的测试程序，在我的笔记本电脑上（intel core i5 2410），很快（迭代1万多次后）就会出现这个结果。<br><br>启动JVM时，请设置为“-server”：在Eclipse中点击右键-&gt;Run Configurations-&gt;Arguments-&gt;VM Arguments</p><p></p>
<p></p><p>程序如下：<br><br>import java.util.concurrent.BrokenBarrierException;<br><br>import java.util.concurrent.Callable;<br><br>import java.util.concurrent.CountDownLatch;<br><br>import java.util.concurrent.ExecutionException;<br><br>import java.util.concurrent.ExecutorService;<br><br>import java.util.concurrent.Executors;<br><br>import java.util.concurrent.Future;</p><p></p>
<p></p><p>public class ReorderTest1 {<br><br>    private int a = 0;<br><br>    private int b = 0;</p><p></p>
<p></p><p>    public static void main(String[] args) throws InterruptedException, ExecutionException {<br><br>        ReorderTest1 rt = new ReorderTest1();<br><br>        rt.doTest();<br><br>    }</p><p></p>
<p></p><p>    public void doTest() throws InterruptedException, ExecutionException{<br><br>        ExecutorService executor = Executors.newFixedThreadPool(2);</p><p></p>
<p></p><p>        for (int i = 1;  i &lt; 1000000; i++) {<br><br>            CountDownLatch latch = new CountDownLatch(1);<br><br>            Future futureA = executor.submit(new ThreadATask(latch));<br><br>            Future futureB = executor.submit(new ThreadBTask(latch));<br><br>            latch.countDown();<br><br>            int x = futureB.get();<br><br>            int y = futureA.get();<br><br>            if (x == y) {<br><br>                System.out.println(“x=” + x + ” : ” + “y=” +  y);<br><br>                System.out.println(“reorder in ” + i);<br><br>                return;<br><br>            }</p><p></p>
<p></p><p>            //重置状态<br><br>            a = 0;<br><br>            b = 0;<br><br>        }<br><br>        //在此关闭线程池<br><br>    }</p><p></p>
<p></p><p>    private class ThreadATask implements Callable {<br><br>        private CountDownLatch barrier;</p><p></p>
<p></p><p>        public ThreadATask(CountDownLatch barrier) {<br><br>            this.barrier = barrier;<br><br>        }</p><p></p>
<p></p><p>        public Integer call() throws InterruptedException, BrokenBarrierException {<br><br>            barrier.await();</p><p></p>
<p></p><p>            a = 1;    // A1<br><br>            return b; // A2<br><br>        }<br><br>    }</p><p></p>
<p></p><p>    private class ThreadBTask implements Callable {<br><br>        private CountDownLatch barrier;</p><p></p>
<p></p><p>        public ThreadBTask(CountDownLatch barrier) {<br><br>            this.barrier = barrier;<br><br>        }</p><p></p>
<p></p><p>        public Integer call() throws InterruptedException, BrokenBarrierException {<br><br>            barrier.await();</p><p></p>
<p></p><p>            b = 2;    // B1<br><br>            return a; // B2<br><br>        }<br><br>    }<br><br>}</p><br>  </div><p></p>
<ul class="children"><br><br> <li class="comment guest-comment even_comment_children" id="comment-26644"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/bce7ab478a04ba9f0471a5ad696152a0?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/bce7ab478a04ba9f0471a5ad696152a0?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-26644"><br><br>veda<br></span><br>     </li><br>     <li class="comment-date">2016/01/22 12:34下午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-26644', 'comment-26644', 'comment-content-26644', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-26644"><br>    <p>使用CountDownLatch做栅栏没错，只不过不应该在主线程里面countDown。因为可能在子线程await之前就已经countDown了，达不到栅栏的效果。<br><br>但其实我试过了其他方法来使两个线程理论上达到“同时执行”的效果，都不行。总会存在某个线程在统计上压倒性的比另一个线程先执行，可能本身执行的指令就很少的缘故吧。不过确实存在指令重排序产生的两值都为零的情况。<br><br>还有我也试了volatile的内存屏障效果，在A1和B1之后只要插入一条任意的的volatile变量写操作就能阻止指令重排序产生的两值都为零的情况。</p><br>  </div><p></p>
<p></p></li><!-- #comment-## --><br></ul><!-- .children --><br></li><!-- #comment-## --><br></ul><!-- .children --><br><!-- #comment-## --><p></p>
<p> <li class="comment guest-comment even_comment" id="comment-1072"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/270c6507031b43ad91f271738a285dbe?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/270c6507031b43ad91f271738a285dbe?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><a id="commentauthor-1072" class="url guest-url" href="http://blueswind8306.iteye.com" rel="noopener" target="_blank"></a></li></ul></div></div></li></p>
<p>高 嵩<br><br>     <br>     <li class="comment-date">2013/05/07 1:07下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-1072', 'comment-1072', 'comment-content-1072', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-1072"><br>    <p>恩，确实如此，多谢耐心解答！</p><br>  </div></p>
<p><!-- #comment-## --></p>
<p> <li class="comment guest-comment odd_comment" id="comment-3180"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://0.gravatar.com/avatar/3e9cfde4c4636a286e572359813c6590?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/3e9cfde4c4636a286e572359813c6590?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-3180"></span></li></ul></div></div></li></p>
<p>俞傲一刀<br><br>     <br>     <li class="comment-date">2013/10/10 2:41下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-3180', 'comment-3180', 'comment-content-3180', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-3180"><br>    <p>文章中说的抽象的线程本地内存和线程存放局部变量的栈不是同一个吧？</p><br>  </div></p>
<p><!-- #comment-## --></p>
<p> <li class="comment guest-comment even_comment" id="comment-8707"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo avatar-default" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-8707"></span></li></ul></div></div></li></p>
<p>nalanjia<br><br>     <br>     <li class="comment-date">2014/04/03 3:03下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-8707', 'comment-8707', 'comment-content-8707', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-8707"><br>    <p>偶丰富了一下上边提到的例子：<br><br>package test034;</p></div></p>
<p></p><p>import java.util.concurrent.BrokenBarrierException;<br><br>import java.util.concurrent.Callable;<br><br>import java.util.concurrent.CountDownLatch;<br><br>import java.util.concurrent.ExecutionException;<br><br>import java.util.concurrent.ExecutorService;<br><br>import java.util.concurrent.Executors;<br><br>import java.util.concurrent.Future;</p><p></p>
<p></p><p>public class ReorderTest {<br><br>    private int a = 0;<br><br>    private int b = 0;</p><p></p>
<p></p><p> public static void main(String[] args) throws InterruptedException,<br><br>            ExecutionException {<br><br>        ReorderTest rt = new ReorderTest();<br><br>        rt.doTest();<br><br>    }</p><p></p>
<p></p><p> public void doTest() throws InterruptedException, ExecutionException {<br><br>        ExecutorService executor = Executors.newFixedThreadPool(2);</p><p></p>
<p></p><p>     //可能出现的结果（关注ThreadATask，ThreadBTask取到的结果）<br><br>        int num00 = 0; //x=0，y=0<br><br>        int num10 = 0; //x=1，y=0<br><br>        int num02 = 0; //x=0，y=2<br><br>        int num12 = 0; //x=1，y=2</p><p></p>
<p></p><p>     //可能出现的结果（关注主线程取到的结果）<br><br>        int main00_a = 0;<br><br>        int main10_a = 0;<br><br>        int main02_a = 0;<br><br>        int main12_a = 0;</p><p></p>
<p></p><p>     //可能出现的结果（关注主线程取到的结果）<br><br>        int main00_b = 0;<br><br>        int main10_b = 0;<br><br>        int main02_b = 0;<br><br>        int main12_b = 0;</p><p></p>
<p></p><p>     int allNum = 100000;<br><br>        for (int i = 0; i &lt; allNum; i++) {</p><p></p>
<p></p><p>         CountDownLatch latch = new CountDownLatch(1);<br><br>            Future futureA = executor.submit(new ThreadATask(latch));<br><br>            Future futureB = executor.submit(new ThreadBTask(latch));<br><br>            latch.countDown();<br><br>            if (a==0 &amp;&amp; b==0) {main00_a++;}<br><br>            if (a==1 &amp;&amp; b==0) {main10_a++;}<br><br>            if (a==0 &amp;&amp; b==2) {main02_a++;}<br><br>            if (a==1 &amp;&amp; b==2) {main12_a++;}</p><p></p>
<p></p><p>         int x = (Integer) futureB.get(); //取得a<br><br>            int y = (Integer) futureA.get(); //取得b</p><p></p>
<p></p><p>         if (x==0 &amp;&amp; y==0) {num00++;}<br><br>            if (x==1 &amp;&amp; y==0) {num10++;}<br><br>            if (x==0 &amp;&amp; y==2) {num02++;}<br><br>            if (x==1 &amp;&amp; y==2) {num12++;}</p><p></p>
<p></p><p>         if (a==0 &amp;&amp; b==0) {main00_b++;}<br><br>            if (a==1 &amp;&amp; b==0) {main10_b++;}<br><br>            if (a==0 &amp;&amp; b==2) {main02_b++;}<br><br>            if (a==1 &amp;&amp; b==2) {main12_b++;}</p><p></p>
<p></p><p>         //重置状态<br><br>            a = 0;<br><br>            b = 0;<br><br>        }<br><br>        System.out.println(“a=0，b=0出现次数：” + main00_a);<br><br>        System.out.println(“a=1，b=0出现次数：” + main10_a);<br><br>        System.out.println(“a=0，b=2出现次数：” + main02_a);<br><br>        System.out.println(“a=1，b=2出现次数：” + main12_a);</p><p></p>
<p></p><p>     System.out.println(“”);<br><br>        System.out.println(“x=0，y=0出现次数：” + num00);<br><br>        System.out.println(“x=1，y=0出现次数：” + num10);<br><br>        System.out.println(“x=0，y=2出现次数：” + num02);<br><br>        System.out.println(“x=1，y=2出现次数：” + num12);</p><p></p>
<p></p><p>     System.out.println(“”);<br><br>        System.out.println(“a=0，b=0出现次数：” + main00_b);<br><br>        System.out.println(“a=1，b=0出现次数：” + main10_b);<br><br>        System.out.println(“a=0，b=2出现次数：” + main02_b);<br><br>        System.out.println(“a=1，b=2出现次数：” + main12_b);<br><br>        executor.shutdown();<br><br>    }</p><p></p>
<p></p><p> private class ThreadATask implements Callable {<br><br>        private CountDownLatch barrier;</p><p></p>
<p></p><p>     public ThreadATask(CountDownLatch barrier) {<br><br>            this.barrier = barrier;<br><br>        }</p><p></p>
<p></p><p>     public Integer call() throws InterruptedException,<br><br>                BrokenBarrierException {<br><br>            barrier.await(); //</p><p></p>
<p></p><p>         a = 1; // A1<br><br>            return b; // A2<br><br>        }<br><br>    }</p><p></p>
<p></p><p> private class ThreadBTask implements Callable {<br><br>        private CountDownLatch barrier;</p><p></p>
<p></p><p>     public ThreadBTask(CountDownLatch barrier) {<br><br>            this.barrier = barrier;<br><br>        }</p><p></p>
<p></p><p>     public Integer call() throws InterruptedException,<br><br>                BrokenBarrierException {<br><br>            barrier.await();</p><p></p>
<p></p><p>         b = 2; // B1<br><br>            return a; // B2<br><br>        }<br><br>    }<br><br>}</p><br>  <p></p>
<ul class="children"><br><br> <li class="comment guest-comment even_comment_children" id="comment-8708"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/?s=35&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo avatar-default" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-8708"><br><br>nalanjia<br></span><br>     </li><br>     <li class="comment-date">2014/04/03 3:04下午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-8708', 'comment-8708', 'comment-content-8708', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-8708"><br>    <p>运行结果为：<br><br>a=0，b=0出现次数：98312<br><br>a=1，b=0出现次数：25<br><br>a=0，b=2出现次数：1<br><br>a=1，b=2出现次数：1678</p><p></p>
<p></p><p>x=0，y=0出现次数：7<br><br>x=1，y=0出现次数：95290<br><br>x=0，y=2出现次数：4701<br><br>x=1，y=2出现次数：2</p><p></p>
<p></p><p>a=0，b=0出现次数：0<br><br>a=1，b=0出现次数：0<br><br>a=0，b=2出现次数：0<br><br>a=1，b=2出现次数：100000</p><br>  </div><p></p>
<p></p></li><!-- #comment-## --><br></ul><!-- .children --><br><!-- #comment-## --><p></p>
<p> <li class="comment guest-comment odd_comment" id="comment-21720"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://1.gravatar.com/avatar/?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo avatar-default" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-21720"></span></li></ul></div></div></li></p>
<p>silence<br><br>     <br>     <li class="comment-date">2014/07/03 11:14下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-21720', 'comment-21720', 'comment-content-21720', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-21720"><br>    <p>你好，对于这一系列文章看了好多遍了，还是不太明白happens-before，假如一个方法中只有两句代码为:this.a=10;int b=20;根据文中指令级排序中说到的“如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序”，那么对于这两句代码而言确实不存在数据依赖性，则处理器就有可能对这两句代码做重排序，先执行int b=20;再执行this.a=10，然后对于文中提到的”程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作”，说明这两个操作之间存在happens- before关系， 虽然happens- before 规则不要求this.a=10一定要在int b=20之前执行，也就符合了处理器对这两个操作做重排序的做法，但是happens- before 却要求”前一个操作（执行的结果）对后一个操作可见”，那么这里的两个操作被处理器重排序过后，this.a=10的操作结果并不一定对int b=20这个操作可见啊！这个是不是矛盾了啊？可能是我的理解出现了错误，还请兄台不吝赐教！谢谢！</p><br>  </div></p>
<ul class="children"><br><br> <li class="comment guest-comment odd_comment_children" id="comment-26700"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/2d60f2d6206602ab9c6c9e68080152de?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/2d60f2d6206602ab9c6c9e68080152de?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-26700"><br><br>wokaole<br></span><br>     </li><br>     <li class="comment-date">2016/02/24 5:36下午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-26700', 'comment-26700', 'comment-content-26700', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-26700"><br>    <p>前面博主有回复过， java内存模型向程序员保证：如果A happens-before B，那么A操作的结果将对B可见，且A的执行顺序排在B之前。<br><br>这仅仅是JMM对程序员的一个保证，如果对 A、B操作进行重排序后，不会对执行结果造成改变，那么java内存模型是允许编译器或处理器对A、B操作进行重排序的。<br><br>程序员对A、B是否进行了重排序可能不太关心，关心的是程序执行的语义不能改变，即程序的执行结果不变。</p><br>  </div><p></p>
<ul class="children"><br><br> <li class="comment guest-comment even_comment_children" id="comment-26968"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/e5e9d003cdf6c5873b358793c24678e1?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/e5e9d003cdf6c5873b358793c24678e1?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-26968"><br><br>ericzou<br></span><br>     </li><br>     <li class="comment-date">2016/06/08 11:48上午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-26968', 'comment-26968', 'comment-content-26968', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-26968"><br>    <p>如果A happens-before B，那么A操作的结果将对B可见，且A的执行顺序排在B之前。对于这句话，有个疑问，如果A和B的操作重排了，还能说A happens-before B吗？感觉这块好绕啊，可是程序次序规则又说线程中的每个操作happens-before后续的操作，这不是互相矛盾吗？</p><br>  </div><p></p>
<p></p></li><!-- #comment-## --><br></ul><!-- .children --><br></li><!-- #comment-## --><br></ul><!-- .children --><br><!-- #comment-## --><p></p>
<p> <li class="comment guest-comment even_comment" id="comment-24120"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://0.gravatar.com/avatar/377074e437bb085138351770105e4e7b?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/377074e437bb085138351770105e4e7b?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-24120"></span></li></ul></div></div></li></p>
<p>changhai614<br><br>     <br>     <li class="comment-date">2014/08/22 5:24下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-24120', 'comment-24120', 'comment-content-24120', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-24120"><br>    <p>写的不错</p><br>  </div></p>
<p><!-- #comment-## --></p>
<p> <li class="comment guest-comment odd_comment" id="comment-26706"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://0.gravatar.com/avatar/ce3dfcb0a5bdd71725749f5173fca761?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/ce3dfcb0a5bdd71725749f5173fca761?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-26706"></span></li></ul></div></div></li></p>
<p>dlbrant<br><br>     <br>     <li class="comment-date">2016/02/25 1:00下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-26706', 'comment-26706', 'comment-content-26706', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-26706"><br>    <p>nice</p><br>  </div></p>
<p><!-- #comment-## --></p>
<p> <li class="comment guest-comment even_comment" id="comment-26926"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/5e242d05d154f3fd67af55ea1ffdcb63?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/5e242d05d154f3fd67af55ea1ffdcb63?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-26926"></span></li></ul></div></div></li></p>
<p>a1345204819<br><br>     <br>     <li class="comment-date">2016/05/23 6:06下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-26926', 'comment-26926', 'comment-content-26926', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-26926"><br>    <p>你好，我有一个疑问，比如在一个类中有一个volatile修饰的变量，然后有两个线程A，B分别对这个变量进行读写操作，那么B线程对该变量的写的结果一定能够被线程A看到吗？也就是说，如果线程B在写入该变量之前要运行100ms其他的一些代码，而线程A在线程B写入操作之前已经运行到自己的读操作，那此时线程A会停下来等待线程B的写入操作呢？还是继续运行，并读取此时该变量的值？</p><br>  </div></p>
<ul class="children"><br><br> <li class="comment guest-comment even_comment_children" id="comment-27156"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://0.gravatar.com/avatar/31a570190aeb6ba02bc18a4e3ab27b01?s=35&amp;d=mm&amp;r=g" srcset="http://0.gravatar.com/avatar/31a570190aeb6ba02bc18a4e3ab27b01?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-27156"><br><br>windranger<br></span><br>     </li><br>     <li class="comment-date">2016/09/27 11:10上午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-27156', 'comment-27156', 'comment-content-27156', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-27156"><br>    <p>看完这一系列文章和评论，发现大家对happens-before和内存可见性都不是太理解，说说我个人的理解，如有错误，敬请指正。第二节重排序中对happens-before定义如下：如果A happens- before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。我觉得可能最后一句“而且一个操作按顺序排在第二个操作之前”混淆了大家对happens-before的理解，认为A happens- before B，则A一定在B之前执行，我觉得应该这么理解这句话，A happens- before B意味着程序不管把AB怎么重排，一定要保证结果和按A-&gt;B顺序执行是一致的，不管怎么重排，后一个执行的操作能看到前一个操作的执行，即使它们在不同的线程中，这样就保证了第三节顺序一致性中说的情况，“未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序”，而不会出现在A看来是A-&gt;B的顺序，而B看来是B-&gt;A的顺序，因为“线程内存”的存在，的确会出现这种很奇怪的情况。通俗一点就是说，对A来说，你B线程说了在我之前执行，就一定要在我之前执行，别你把共享内存中的变量取走了，缓存到“线程内存”，做了修改却没通知我，导致我没取到最新的共享内存变量，这就跟SVN的冲突一样了，两个人都同时对某文件做了修改，如果没有SVN的解决冲突，那必将导致丢失一个人的修改。所以happens-before和内存可见性就是保证了写操作的原子性，也就是volatile关键字的作用。</p><br>  </div><p></p>
<p></p></li><!-- #comment-## --><br></ul><!-- .children --><br><!-- #comment-## --><p></p>
<p> <li class="comment guest-comment odd_comment" id="comment-27369"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/522b21477ce640652c9c8f9d805157ed?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/522b21477ce640652c9c8f9d805157ed?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-27369"></span></li></ul></div></div></li></p>
<p>cindy_cao<br><br>     <br>     <li class="comment-date">2017/01/12 4:27下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-27369', 'comment-27369', 'comment-content-27369', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-27369"><br>    <p>引用”由于现代的processor都会使用写缓冲区，因此现代的processor都会允许对写-读操作重排序。”,为什么所有的processor都支持写-读重排序,不支持读-读重排序呢?读-读不应该更不会影响最终结果的正确性吗?</p><br>  </div></p>
<p><!-- #comment-## --></p>
<p> <li class="comment guest-comment even_comment" id="comment-27374"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/522b21477ce640652c9c8f9d805157ed?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/522b21477ce640652c9c8f9d805157ed?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-27374"></span></li></ul></div></div></li></p>
<p>cindy_cao<br><br>     <br>     <li class="comment-date">2017/01/12 6:43下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-27374', 'comment-27374', 'comment-content-27374', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-27374"><br>    <p>引用”StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。”本人理解的StoreLoad Barriers只是写-读内存屏障,为什么从这句话中读到的意思是读-读,写-读操作呢?后还提到具备3个内存屏障的效果是什么意思?</p><br>  </div></p>
<p><!-- #comment-## --></p>
<p> <li class="comment guest-comment odd_comment" id="comment-27416"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/5f10998c4508557e26dd895a28458746?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/5f10998c4508557e26dd895a28458746?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-27416"></span></li></ul></div></div></li></p>
<p>channel<br><br>     <br>     <li class="comment-date">2017/02/13 4:28下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-27416', 'comment-27416', 'comment-content-27416', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-27416"><br>    <p>文章说 ： 在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p></div></p>
<p></p><p>为什么又说 Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行， </p><p></p>
<p></p><p>不是说消息传递的并发模型里，才是隐式进行的吗。</p><br>  <p></p>
<ul class="children"><br><br> <li class="comment guest-comment odd_comment_children" id="comment-27435"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/522b21477ce640652c9c8f9d805157ed?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/522b21477ce640652c9c8f9d805157ed?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-27435"><br><br>cindy_cao<br></span><br>     </li><br>     <li class="comment-date">2017/02/22 11:04上午</li><br>    </ul><br>   </div><br><br>   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-27435', 'comment-27435', 'comment-content-27435', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  </p></div><br>  <div class="comment-content" id="comment-content-27435"><br>    <p>说的很对啊,java的并发是共享内存模型,而你说的是消息传递的并发模型,两个模型不一样,是不是看花了?</p><br>  </div><p></p>
<p></p></li><!-- #comment-## --><br></ul><!-- .children --><br><!-- #comment-## --><p></p>
<p> <li class="comment guest-comment even_comment" id="comment-27609"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://1.gravatar.com/avatar/a1723e5d1d844c2c8a27b2627875f029?s=35&amp;d=mm&amp;r=g" srcset="http://1.gravatar.com/avatar/a1723e5d1d844c2c8a27b2627875f029?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-27609"></span></li></ul></div></div></li></p>
<p>lionheartyd<br><br>     <br>     <li class="comment-date">2017/04/26 6:12下午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-27609', 'comment-27609', 'comment-content-27609', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-27609"><br>    <p>文中多次提到处理器写缓冲，因此造成一些列的重排序可见性问题，我想问的是，处理器再从内存读取数据时会有读缓冲吗？比如A线程读取了变量i, 此后B线程修改了变量i并写入了主存，此时A线程再次读取变量i时，它是从主存读呢还是读取缓存呢？</p><br>  </div></p>
<p><!-- #comment-## --></p>
<p> <li class="comment guest-comment odd_comment" id="comment-27877"><br>  <div class="comment-meta"><br>   <div class="comment-meta-left"><br>  <img alt="" src="http://2.gravatar.com/avatar/5d578df5ea608313f8e9cb25fc9fb424?s=35&amp;d=mm&amp;r=g" srcset="http://2.gravatar.com/avatar/5d578df5ea608313f8e9cb25fc9fb424?s=70&amp;d=mm&amp;r=g 2x" class="avatar avatar-35 photo" height="35" width="35"><br>    <ul class="comment-name-date"><br>     <li class="comment-name"><br><span id="commentauthor-27877"></span></li></ul></div></div></li></p>
<p>jimmie<br><br>     <br>     <li class="comment-date">2017/08/03 11:41上午</li><br>    <br>   </p>
   <ul class="comment-act"><br>    <li class="comment-reply"><a rel="noopener" class="comment-reply-login" href="http://ifeve.com/wp-login.php?redirect_to=http%3A%2F%2Fifeve.com%2Fjava-memory-model-1%2F" target="_blank">登录以回复</a></li><br>    <li class="comment-quote"><a href="javascript:void(0);" onclick="MGJS_CMT.quote('commentauthor-27877', 'comment-27877', 'comment-content-27877', 'comment');" target="_blank" rel="noopener">引用</a></li><br>       </ul>

<p>  <br>  <div class="comment-content" id="comment-content-27877"><br>    <p>“这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。<br><br>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）”</p></div></p>
<p></p><p>你好，有一点有疑问，关于这个x=y=0的case，应该不会发生吧？根据缓存一致性协议，在修改缓存中a或者b的值，会导致其他的cpu缓存失效啊，然后会从主存重新读，这会触发缓存中的a或者b会刷新到主存，所以，重新读读取到的肯定是修改后的值，然后再复制给x或者y。不知道我这样理解对不对</p><br>  <p></p>
<p><!-- #comment-## --><br>  <br>  <!-- comments END --></p>
<p> <!-- #comment-list END --></p>
 <div id="trackback_area"><br> <!-- start trackback --><br>  <!-- trackback end --><br> </div><!-- #trackbacklist END --><br><br><br><br><br><br> <div class="comment_form_wrapper" id="respond"><br>    您必须 <a href="http://ifeve.com/wp-login.php" target="_blank" rel="noopener">登陆</a> 后才能发表评论 </div>

<p> <!-- #comment end -->   </p>
<pre><code>  &lt;div id=&quot;previous_next_post_single&quot;&gt;
&lt;div class=&quot;clearfix&quot;&gt;
 &lt;p id=&quot;previous_post&quot;&gt;&lt;a href=&quot;http://ifeve.com/cancellation/&quot; rel=&quot;prev&quot;&gt;任务取消(Cancellation)&lt;/a&gt;&lt;/p&gt;     &lt;p id=&quot;next_post&quot;&gt;&lt;a href=&quot;http://ifeve.com/who-is-lock/&quot; rel=&quot;next&quot;&gt;哪个对象才是锁？&lt;/a&gt;&lt;/p&gt;    &lt;/div&gt;
</code></pre><p>   </p>
<p>  <!-- END #left_col --></p>
  <div id="container"></div>

<pre><code>&lt;div id=&quot;right_col&quot;&gt;
</code></pre><div class="side_box clearfix" id="side_meta_content"><br><br>  <ul id="social_link" class="clearfix"><br>    <li class="rss_button"><a class="target_blank" href="http://ifeve.com/feed/" target="_blank">rss</a></li><br>       </ul><br><br>  <div id="search_area"><br>    <form method="get" id="searchform" action="http://ifeve.com/"><br>   <div><input id="search_button" class="rollover" type="image" src="http://ifeve.com/wp-content/themes/flat/img/search_button.gif" alt="搜索一下" title="搜索一下"></div><br>   <div><input id="search_input" type="text" value="搜索一下" name="s" onfocus="if (this.value == '搜索一下') this.value = '';" onblur="if (this.value == '') this.value = '搜索一下';"></div><br>  </form><br>   </div>

<p></p></div><p></p>
<div id="side_top"><br><br> <div class="widget_text side_box widget_custom_html" id="custom_html-3"><br><div class="textwidget custom-html-widget"><br><br><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br><!-- 首页－右上－2 --><br><ins class="adsbygoogle" style="display: inline-block; width: 319px; height: 280px;" data-ad-client="ca-pub-9394337417063147" data-ad-slot="8872369516" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:319px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:319px;background-color:transparent;"><iframe width="319" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;border:0px;width:319px;height:280px;"></iframe></ins></ins></ins><br><script><br>(adsbygoogle = window.adsbygoogle || []).push({});<br></script><br><br><br><br><br><br><!-- <img src="http://ifeve.com/wp-content/uploads/2018/06/qrcode_for_gh_87611be4f171_258.jpg"/> --><br><br><!-- <a target="_blank" href="http://edu.bjlemon.com:81/index.html"><img src="http://ifeve.com/wp-content/uploads/2018/06/qrcode_for_gh_87611be4f171_258.jpg"/>
 --></div></div><br>        <div class="side_box widget_recent_entries" id="recent-posts-2"><br>        <h3 class="side_title">近期文章</h3><br>        <ul><br>                                            <li><br>                    <a href="http://ifeve.com/network/" target="_blank" rel="noopener">白话网络通讯</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e5%9f%ba%e4%ba%8eredis%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81/" target="_blank" rel="noopener">基于redis的分布式锁</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e7%8c%ab%e7%8b%97%e9%98%9f%e5%88%97%e7%9a%84%e5%86%8d%e8%a7%a3/" target="_blank" rel="noopener">猫狗队列的再解</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e5%a6%82%e4%bd%95%e6%88%90%e4%b8%ba%e4%b8%80%e4%bd%8d%e3%80%8c%e4%b8%8d%e9%82%a3%e4%b9%88%e5%b7%ae%e3%80%8d%e7%9a%84%e7%a8%8b%e5%ba%8f%e5%91%98/" target="_blank" rel="noopener">如何成为一位「不那么差」的程序员</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e4%ba%8c%e4%b8%89%e4%ba%8b/" target="_blank" rel="noopener">消息队列二三事</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e7%99%be%e4%b8%87%e7%ba%a7%e7%9a%84%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81%e7%b3%bb%e7%bb%9f/" target="_blank" rel="noopener">设计一个百万级的消息推送系统</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e3%80%8apython3-6%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e3%80%8b-4-%e6%9b%b4%e5%a4%9a%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%e8%af%ad%e5%8f%a5/" target="_blank" rel="noopener">《Python3.6官方文档》– 4.更多流程控制语句</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/the-beauty-of-javas-concurrent-programming/" target="_blank" rel="noopener">Java并发编程之美</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/java-cyclicbarrier/" target="_blank" rel="noopener">java多线程系列：通过对战游戏学习CyclicBarrier</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e3%80%8apython3-6%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e3%80%8b14-%e7%ab%a0/" target="_blank" rel="noopener">《Python3.6官方文档》14 章</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90kafka%e4%b9%8bproducer/" target="_blank" rel="noopener">源码分析Kafka之Producer</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e5%ae%b9%e5%99%a8docker%e4%b8%ad%e8%bf%90%e8%a1%8cjava%e9%9c%80%e5%85%b3%e6%b3%a8%e7%9a%84%e5%87%a0%e4%b8%aa%e5%b0%8f%e9%97%ae%e9%a2%98/" target="_blank" rel="noopener">容器(docker)中运行java需关注的几个小问题</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e5%a6%82%e4%bd%95%e4%bc%98%e9%9b%85%e7%9a%84%e4%bd%bf%e7%94%a8%e5%92%8c%e7%90%86%e8%a7%a3%e7%ba%bf%e7%a8%8b%e6%b1%a0/" target="_blank" rel="noopener">如何优雅的使用和理解线程池</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/python3-6-12/" target="_blank" rel="noopener">《Python3.6官方文档》– 第12章 虚拟环境和包</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/python-3-6-13/" target="_blank" rel="noopener">《Python3.6官方文档》– 第13章  接下来</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/hashmap-concurrenthashmap-%e7%9b%b8%e4%bf%a1%e7%9c%8b%e5%ae%8c%e8%bf%99%e7%af%87%e6%b2%a1%e4%ba%ba%e8%83%bd%e9%9a%be%e4%bd%8f%e4%bd%a0%ef%bc%81/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/raft%e8%ae%ba%e6%96%87%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/" target="_blank" rel="noopener">Raft论文读书笔记</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e3%80%8apython3-6%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e3%80%8b-%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e4%bd%bf%e7%94%a8python%e8%a7%a3%e9%87%8a%e5%99%a8/" target="_blank" rel="noopener">《Python3.6官方文档》– 第二章 使用python解释器</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e4%bd%a0%e7%9c%9f%e7%9a%84%e4%ba%86%e8%a7%a3%e5%bb%b6%e6%97%b6%e9%98%9f%e5%88%97%e5%90%97%e4%b8%80/" target="_blank" rel="noopener">你真的了解延时队列吗(一)</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/mysq-stream-search/" target="_blank" rel="noopener">MySQL中流式查询使用</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/python3-6-10/" target="_blank" rel="noopener">《Python3.6官方文档》– 第十章</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/ethereum-clients-choosing-a-client/" target="_blank" rel="noopener">《以太坊官方文档》Ethereum Clients—Choosing a client</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/what-is-ethereum/" target="_blank" rel="noopener">《以太坊官方文档》什么是以太坊（What is Ethereum?）</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/python-5/" target="_blank" rel="noopener">《Python官方文档》5.数据结构</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/netty%e4%ba%8c-%e4%bb%8e%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e7%9a%84%e8%a7%92%e5%ba%a6%e7%9c%8b-netty-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e9%ab%98%e6%80%a7%e8%83%bd%e7%9a%84%ef%bc%9f/" target="_blank" rel="noopener">Netty(二) 从线程模型的角度看 Netty 为什么是高性能的？</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/%e5%88%9d%e8%b0%88%e6%9e%b6%e6%9e%84/" target="_blank" rel="noopener">初谈架构</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/rocketmq-concept/" target="_blank" rel="noopener">分布式消息中间件 RocketMQ：概述与源码编译篇</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/guava-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%ef%bc%88cache-%e5%8e%9f%e7%90%86%e3%80%90%e4%ba%8c%e9%98%b6%e6%ae%b5%e3%80%91%ef%bc%89/" target="_blank" rel="noopener">Guava 源码分析（Cache 原理【二阶段】）</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/apache-pulsar%e4%bb%8b%e7%bb%8d/" target="_blank" rel="noopener">Apache Pulsar介绍</a><br>                                    </li><br>                                            <li><br>                    <a href="http://ifeve.com/ethereum/" target="_blank" rel="noopener">《以太坊官方文档》翻译邀请</a><br>                                    </li><br>                    </ul><br>        </div><br><div class="widget_text side_box widget_custom_html" id="custom_html-5"><br><div class="textwidget custom-html-widget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br><!-- 首页－右上－3 --><br><ins class="adsbygoogle" style="display: inline-block; width: 319px; height: 280px;" data-ad-client="ca-pub-9394337417063147" data-ad-slot="4721371513" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:319px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:319px;background-color:transparent;"><iframe width="319" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0px;width:319px;height:280px;"></iframe></ins></ins></ins><br><script><br>(adsbygoogle = window.adsbygoogle || []).push({});<br></script></div></div><br><div class="side_box widget_views" id="views-4"><br><h3 class="side_title">热门文章</h3><br><ul><br><li><a href="http://ifeve.com/java-memory-model-1/" title="Google Guava官方教程（中文版）" target="_blank" rel="noopener">Google Guava官方教程（中文版）</a> 620,123 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java NIO系列教程（一） Java NIO 概述" target="_blank" rel="noopener">Java NIO系列教程（一） Java NIO 概述</a> 461,901 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java并发性和多线程介绍目录" target="_blank" rel="noopener">Java并发性和多线程介绍目录</a> 333,944 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java NIO 系列教程" target="_blank" rel="noopener">Java NIO 系列教程</a> 325,982 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java NIO系列教程（十二） Java NIO与IO" target="_blank" rel="noopener">Java NIO系列教程（十二） Java NIO与IO</a> 256,488 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java8初体验（二）Stream语法详解" target="_blank" rel="noopener">Java8初体验（二）Stream语法详解</a> 233,847 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java NIO系列教程（六） Selector" target="_blank" rel="noopener">Java NIO系列教程（六） Selector</a> 229,043 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java NIO系列教程（三） Buffer" target="_blank" rel="noopener">Java NIO系列教程（三） Buffer</a> 226,797 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java NIO系列教程（二） Channel" target="_blank" rel="noopener">Java NIO系列教程（二） Channel</a> 221,562 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="69道Spring面试题和答案" target="_blank" rel="noopener">69道Spring面试题和答案</a> 183,381 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="《Storm入门》中文版" target="_blank" rel="noopener">《Storm入门》中文版</a> 182,955 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Netty 5用户指南" target="_blank" rel="noopener">Netty 5用户指南</a> 176,075 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="并发框架Disruptor译文" target="_blank" rel="noopener">并发框架Disruptor译文</a> 162,653 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="面试题" target="_blank" rel="noopener">面试题</a> 158,260 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java 7 并发编程指南中文版" target="_blank" rel="noopener">Java 7 并发编程指南中文版</a> 145,535 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="Java NIO系列教程（八） SocketChannel" target="_blank" rel="noopener">Java NIO系列教程（八） SocketChannel</a> 143,811 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="[Google Guava] 2.3-强大的集合工具类：ja..." target="_blank" rel="noopener">[Google Guava] 2.3-强大的集合工具类：ja…</a> 139,163 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="[Google Guava] 3-缓存" target="_blank" rel="noopener">[Google Guava] 3-缓存</a> 139,147 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="聊聊并发（三）Java线程池的分析和使用" target="_blank" rel="noopener">聊聊并发（三）Java线程池的分析和使用</a> 132,806 人阅读 </li><li><a href="http://ifeve.com/java-memory-model-1/" title="如何创建并运行java线程" target="_blank" rel="noopener">如何创建并运行java线程</a> 132,710 人阅读 </li></ul><br></div><br><div class="widget_text side_box widget_custom_html" id="custom_html-4"><br><div class="textwidget custom-html-widget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br><!-- 首页－右边－4 --><br><ins class="adsbygoogle" style="display: inline-block; width: 319px; height: 280px;" data-ad-client="ca-pub-9394337417063147" data-ad-slot="6198104715" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:319px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:319px;background-color:transparent;"><iframe width="319" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;border:0px;width:319px;height:280px;"></iframe></ins></ins></ins><br><script><br>(adsbygoogle = window.adsbygoogle || []).push({});<br></script></div></div><br></div><br><div id="side_middle" class="clearfix"><br> <div id="side_left"><br>  <div class="side_box_short widget_categories" id="categories-2"><br><h3 class="side_title">分类目录</h3><br>        <ul><br>    <li class="cat-item cat-item-415"><a href="http://ifeve.com/category/android/" target="_blank" rel="noopener">Android</a> (3)<br></li><br>    <li class="cat-item cat-item-1101"><a href="http://ifeve.com/category/architecture/" target="_blank" rel="noopener">Architecture</a> (2)<br></li><br>    <li class="cat-item cat-item-289"><a href="http://ifeve.com/category/c/" target="_blank" rel="noopener">C++</a> (12)<br></li><br>    <li class="cat-item cat-item-366"><a href="http://ifeve.com/category/cpu-2/" target="_blank" rel="noopener">CPU</a> (2)<br></li><br>    <li class="cat-item cat-item-73"><a href="http://ifeve.com/category/framework/" target="_blank" rel="noopener">Framework</a> (74)<br><ul class="children"><br>    <li class="cat-item cat-item-387"><a href="http://ifeve.com/category/framework/akka/" target="_blank" rel="noopener">akka</a> (20)<br></li><br></ul><br></li><br>    <li class="cat-item cat-item-458"><a href="http://ifeve.com/category/go/" target="_blank" rel="noopener">GO</a> (6)<br></li><br>    <li class="cat-item cat-item-617"><a href="http://ifeve.com/category/groovy/" target="_blank" rel="noopener">groovy</a> (6)<br></li><br>    <li class="cat-item cat-item-310"><a href="http://ifeve.com/category/guava-2/" target="_blank" rel="noopener">guava</a> (24)<br></li><br>    <li class="cat-item cat-item-69"><a href="http://ifeve.com/category/java/" target="_blank" rel="noopener">JAVA</a> (910)<br></li><br>    <li class="cat-item cat-item-127"><a href="http://ifeve.com/category/jvm/" target="_blank" rel="noopener">JVM</a> (46)<br></li><br>    <li class="cat-item cat-item-300"><a href="http://ifeve.com/category/linux/" target="_blank" rel="noopener">linux</a> (10)<br></li><br>    <li class="cat-item cat-item-1061"><a href="http://ifeve.com/category/microservices/" target="_blank" rel="noopener">microservices</a> (1)<br></li><br>    <li class="cat-item cat-item-280"><a href="http://ifeve.com/category/netty/" target="_blank" rel="noopener">Netty</a> (32)<br></li><br>    <li class="cat-item cat-item-1107"><a href="http://ifeve.com/category/python/" target="_blank" rel="noopener">Python</a> (2)<br></li><br>    <li class="cat-item cat-item-632"><a href="http://ifeve.com/category/react/" target="_blank" rel="noopener">react</a> (6)<br></li><br>    <li class="cat-item cat-item-623"><a href="http://ifeve.com/category/redis/" target="_blank" rel="noopener">redis</a> (25)<br></li><br>    <li class="cat-item cat-item-166"><a href="http://ifeve.com/category/scala/" target="_blank" rel="noopener">Scala</a> (11)<br></li><br>    <li class="cat-item cat-item-672"><a href="http://ifeve.com/category/spark/" target="_blank" rel="noopener">spark</a> (19)<br></li><br>    <li class="cat-item cat-item-1011"><a href="http://ifeve.com/category/spring/" target="_blank" rel="noopener">Spring</a> (23)<br></li><br>    <li class="cat-item cat-item-388"><a href="http://ifeve.com/category/storm/" target="_blank" rel="noopener">storm</a> (44)<br></li><br>    <li class="cat-item cat-item-620"><a href="http://ifeve.com/category/thinking/" target="_blank" rel="noopener">thinking</a> (3)<br></li><br>    <li class="cat-item cat-item-485"><a href="http://ifeve.com/category/velocity/" target="_blank" rel="noopener">Velocity</a> (10)<br></li><br>    <li class="cat-item cat-item-279"><a href="http://ifeve.com/category/web/" target="_blank" rel="noopener">Web</a> (18)<br></li><br>    <li class="cat-item cat-item-980"><a href="http://ifeve.com/category/zookeeper/" target="_blank" rel="noopener">zookeeper</a> (1)<br></li><br>    <li class="cat-item cat-item-148"><a href="http://ifeve.com/category/notice/" target="_blank" rel="noopener">公告</a> (5)<br></li><br>    <li class="cat-item cat-item-1103"><a href="http://ifeve.com/category/%e5%8c%ba%e5%9d%97%e9%93%be/" target="_blank" rel="noopener">区块链</a> (3)<br></li><br>    <li class="cat-item cat-item-378"><a href="http://ifeve.com/category/bigdata/" target="_blank" rel="noopener">大数据</a> (35)<br></li><br>    <li class="cat-item cat-item-138"><a href="http://ifeve.com/category/%e5%a5%bd%e6%96%87%e6%8e%a8%e8%8d%90/" target="_blank" rel="noopener">好文推荐</a> (34)<br></li><br>    <li class="cat-item cat-item-244"><a href="http://ifeve.com/category/%e5%b9%b6%e5%8f%91%e4%b9%a6%e7%b1%8d/" target="_blank" rel="noopener">并发书籍</a> (97)<br></li><br>    <li class="cat-item cat-item-29"><a href="http://ifeve.com/category/concurrency-translation/" title="发布国外并发编程相关文献译文。" target="_blank" rel="noopener">并发译文</a> (416)<br></li><br>    <li class="cat-item cat-item-979"><a href="http://ifeve.com/category/%e6%84%9f%e6%82%9f/" target="_blank" rel="noopener">感悟</a> (5)<br></li><br>    <li class="cat-item cat-item-7"><a href="http://ifeve.com/category/ask/" title="可以在这里发表并发编程的问题。如何发表？用QQ登陆，然后点击“新建文章”，管理员审核后就可以发表。" target="_blank" rel="noopener">技术问答</a> (12)<br></li><br>    <li class="cat-item cat-item-147"><a href="http://ifeve.com/category/%e6%95%8f%e6%8d%b7%e7%ae%a1%e7%90%86/" target="_blank" rel="noopener">敏捷管理</a> (6)<br></li><br>    <li class="cat-item cat-item-1"><a href="http://ifeve.com/category/talk-concurrent/" target="_blank" rel="noopener">本站原创</a> (89)<br></li><br>    <li class="cat-item cat-item-367"><a href="http://ifeve.com/category/%e6%9e%b6%e6%9e%84/" target="_blank" rel="noopener">架构</a> (38)<br></li><br>    <li class="cat-item cat-item-305"><a href="http://ifeve.com/category/%e6%b4%bb%e5%8a%a8/" target="_blank" rel="noopener">活动</a> (6)<br></li><br>    <li class="cat-item cat-item-414"><a href="http://ifeve.com/category/%e7%bd%91%e7%bb%9c/" target="_blank" rel="noopener">网络</a> (7)<br></li><br>    <li class="cat-item cat-item-1100"><a href="http://ifeve.com/category/%e9%9d%a2%e8%af%95/" target="_blank" rel="noopener">面试</a> (1)<br></li><br>        </ul><br></div><br> </div><br> <div id="side_right"><br>  <div class="side_box_short widget_tag_cloud" id="tag_cloud-4"><br><h3 class="side_title">标签</h3><br><div class="tagcloud"><a href="http://ifeve.com/tag/actor/" class="tag-cloud-link tag-link-226 tag-link-position-1" style="font-size: 12.421052631579pt;" aria-label="actor (17个项目)" target="_blank" rel="noopener">actor</a><br><a href="http://ifeve.com/tag/basic/" class="tag-cloud-link tag-link-213 tag-link-position-2" style="font-size: 11.438596491228pt;" aria-label="Basic (14个项目)" target="_blank" rel="noopener">Basic</a><br><a href="http://ifeve.com/tag/classes/" class="tag-cloud-link tag-link-251 tag-link-position-3" style="font-size: 8.6140350877193pt;" aria-label="classes (8个项目)" target="_blank" rel="noopener">classes</a><br><a href="http://ifeve.com/tag/collections/" class="tag-cloud-link tag-link-260 tag-link-position-4" style="font-size: 10.210526315789pt;" aria-label="collections (11个项目)" target="_blank" rel="noopener">collections</a><br><a href="http://ifeve.com/tag/concurrency/" class="tag-cloud-link tag-link-111 tag-link-position-5" style="font-size: 20.157894736842pt;" aria-label="concurrency (77个项目)" target="_blank" rel="noopener">concurrency</a><br><a href="http://ifeve.com/tag/concurrent/" class="tag-cloud-link tag-link-214 tag-link-position-6" style="font-size: 11.070175438596pt;" aria-label="Concurrent (13个项目)" target="_blank" rel="noopener">Concurrent</a><br><a href="http://ifeve.com/tag/concurrent-data-structure/" class="tag-cloud-link tag-link-322 tag-link-position-7" style="font-size: 11.070175438596pt;" aria-label="concurrent data structure (13个项目)" target="_blank" rel="noopener">concurrent data structure</a><br><a href="http://ifeve.com/tag/concurrenthashmap/" class="tag-cloud-link tag-link-61 tag-link-position-8" style="font-size: 8pt;" aria-label="ConcurrentHashMap (7个项目)" target="_blank" rel="noopener">ConcurrentHashMap</a><br><a href="http://ifeve.com/tag/customizing/" class="tag-cloud-link tag-link-250 tag-link-position-9" style="font-size: 8.6140350877193pt;" aria-label="Customizing (8个项目)" target="_blank" rel="noopener">Customizing</a><br><a href="http://ifeve.com/tag/executor/" class="tag-cloud-link tag-link-177 tag-link-position-10" style="font-size: 13.157894736842pt;" aria-label="Executor (20个项目)" target="_blank" rel="noopener">Executor</a><br><a href="http://ifeve.com/tag/executor-framework/" class="tag-cloud-link tag-link-231 tag-link-position-11" style="font-size: 12.666666666667pt;" aria-label="Executor framework (18个项目)" target="_blank" rel="noopener">Executor framework</a><br><a href="http://ifeve.com/tag/faq/" class="tag-cloud-link tag-link-39 tag-link-position-12" style="font-size: 11.070175438596pt;" aria-label="faq (13个项目)" target="_blank" rel="noopener">faq</a><br><a href="http://ifeve.com/tag/fork/" class="tag-cloud-link tag-link-232 tag-link-position-13" style="font-size: 10.578947368421pt;" aria-label="fork (12个项目)" target="_blank" rel="noopener">fork</a><br><a href="http://ifeve.com/tag/forkjoin/" class="tag-cloud-link tag-link-224 tag-link-position-14" style="font-size: 9.2280701754386pt;" aria-label="Fork/Join (9个项目)" target="_blank" rel="noopener">Fork/Join</a><br><a href="http://ifeve.com/tag/fork-join/" class="tag-cloud-link tag-link-53 tag-link-position-15" style="font-size: 8.6140350877193pt;" aria-label="fork join (8个项目)" target="_blank" rel="noopener">fork join</a><br><a href="http://ifeve.com/tag/framework/" class="tag-cloud-link tag-link-1018 tag-link-position-16" style="font-size: 14.263157894737pt;" aria-label="Framework (25个项目)" target="_blank" rel="noopener">Framework</a><br><a href="http://ifeve.com/tag/functional-programming/" class="tag-cloud-link tag-link-460 tag-link-position-17" style="font-size: 9.719298245614pt;" aria-label="Functional Programming (10个项目)" target="_blank" rel="noopener">Functional Programming</a><br><a href="http://ifeve.com/tag/guava/" class="tag-cloud-link tag-link-309 tag-link-position-18" style="font-size: 12.421052631579pt;" aria-label="Guava (17个项目)" target="_blank" rel="noopener">Guava</a><br><a href="http://ifeve.com/tag/io/" class="tag-cloud-link tag-link-129 tag-link-position-19" style="font-size: 14.508771929825pt;" aria-label="IO (26个项目)" target="_blank" rel="noopener">IO</a><br><a href="http://ifeve.com/tag/java/" class="tag-cloud-link tag-link-1016 tag-link-position-20" style="font-size: 22pt;" aria-label="JAVA (109个项目)" target="_blank" rel="noopener">JAVA</a><br><a href="http://ifeve.com/tag/java8/" class="tag-cloud-link tag-link-342 tag-link-position-21" style="font-size: 11.070175438596pt;" aria-label="java8 (13个项目)" target="_blank" rel="noopener">java8</a><br><a href="http://ifeve.com/tag/jmm/" class="tag-cloud-link tag-link-31 tag-link-position-22" style="font-size: 15.614035087719pt;" aria-label="jmm (32个项目)" target="_blank" rel="noopener">jmm</a><br><a href="http://ifeve.com/tag/join/" class="tag-cloud-link tag-link-233 tag-link-position-23" style="font-size: 10.578947368421pt;" aria-label="join (12个项目)" target="_blank" rel="noopener">join</a><br><a href="http://ifeve.com/tag/jvm/" class="tag-cloud-link tag-link-1019 tag-link-position-24" style="font-size: 13.40350877193pt;" aria-label="JVM (21个项目)" target="_blank" rel="noopener">JVM</a><br><a href="http://ifeve.com/tag/lock/" class="tag-cloud-link tag-link-17 tag-link-position-25" style="font-size: 14.508771929825pt;" aria-label="lock (26个项目)" target="_blank" rel="noopener">lock</a><br><a href="http://ifeve.com/tag/memory-barriers/" class="tag-cloud-link tag-link-75 tag-link-position-26" style="font-size: 9.719298245614pt;" aria-label="Memory Barriers (10个项目)" target="_blank" rel="noopener">Memory Barriers</a><br><a href="http://ifeve.com/tag/netty/" class="tag-cloud-link tag-link-1027 tag-link-position-27" style="font-size: 13.40350877193pt;" aria-label="Netty (21个项目)" target="_blank" rel="noopener">Netty</a><br><a href="http://ifeve.com/tag/nio/" class="tag-cloud-link tag-link-1021 tag-link-position-28" style="font-size: 12.421052631579pt;" aria-label="NIO (17个项目)" target="_blank" rel="noopener">NIO</a><br><a href="http://ifeve.com/tag/oauth-2-0/" class="tag-cloud-link tag-link-380 tag-link-position-29" style="font-size: 8.6140350877193pt;" aria-label="OAuth 2.0 (8个项目)" target="_blank" rel="noopener">OAuth 2.0</a><br><a href="http://ifeve.com/tag/pattern-matching/" class="tag-cloud-link tag-link-167 tag-link-position-30" style="font-size: 8.6140350877193pt;" aria-label="pattern-matching (8个项目)" target="_blank" rel="noopener">pattern-matching</a><br><a href="http://ifeve.com/tag/ringbuffer/" class="tag-cloud-link tag-link-91 tag-link-position-31" style="font-size: 8pt;" aria-label="RingBuffer (7个项目)" target="_blank" rel="noopener">RingBuffer</a><br><a href="http://ifeve.com/tag/scala/" class="tag-cloud-link tag-link-1023 tag-link-position-32" style="font-size: 13.649122807018pt;" aria-label="Scala (22个项目)" target="_blank" rel="noopener">Scala</a><br><a href="http://ifeve.com/tag/service-mesh/" class="tag-cloud-link tag-link-1063 tag-link-position-33" style="font-size: 8.6140350877193pt;" aria-label="service mesh (8个项目)" target="_blank" rel="noopener">service mesh</a><br><a href="http://ifeve.com/tag/slf4j/" class="tag-cloud-link tag-link-813 tag-link-position-34" style="font-size: 8.6140350877193pt;" aria-label="slf4j (8个项目)" target="_blank" rel="noopener">slf4j</a><br><a href="http://ifeve.com/tag/spark/" class="tag-cloud-link tag-link-634 tag-link-position-35" style="font-size: 12.421052631579pt;" aria-label="spark (17个项目)" target="_blank" rel="noopener">spark</a><br><a href="http://ifeve.com/tag/spark%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3/" class="tag-cloud-link tag-link-635 tag-link-position-36" style="font-size: 12.421052631579pt;" aria-label="spark官方文档 (17个项目)" target="_blank" rel="noopener">spark官方文档</a><br><a href="http://ifeve.com/tag/stm/" class="tag-cloud-link tag-link-199 tag-link-position-37" style="font-size: 10.578947368421pt;" aria-label="stm (12个项目)" target="_blank" rel="noopener">stm</a><br><a href="http://ifeve.com/tag/storm/" class="tag-cloud-link tag-link-351 tag-link-position-38" style="font-size: 16.59649122807pt;" aria-label="Storm (39个项目)" target="_blank" rel="noopener">Storm</a><br><a href="http://ifeve.com/tag/synchronization/" class="tag-cloud-link tag-link-216 tag-link-position-39" style="font-size: 11.684210526316pt;" aria-label="synchronization (15个项目)" target="_blank" rel="noopener">synchronization</a><br><a href="http://ifeve.com/tag/synchronized/" class="tag-cloud-link tag-link-15 tag-link-position-40" style="font-size: 9.719298245614pt;" aria-label="Synchronized (10个项目)" target="_blank" rel="noopener">Synchronized</a><br><a href="http://ifeve.com/tag/thread/" class="tag-cloud-link tag-link-11 tag-link-position-41" style="font-size: 17.210526315789pt;" aria-label="thread (44个项目)" target="_blank" rel="noopener">thread</a><br><a href="http://ifeve.com/tag/tomcat/" class="tag-cloud-link tag-link-347 tag-link-position-42" style="font-size: 9.2280701754386pt;" aria-label="tomcat (9个项目)" target="_blank" rel="noopener">tomcat</a><br><a href="http://ifeve.com/tag/volatile/" class="tag-cloud-link tag-link-25 tag-link-position-43" style="font-size: 11.438596491228pt;" aria-label="volatile (14个项目)" target="_blank" rel="noopener">volatile</a><br><a href="http://ifeve.com/tag/%e5%a4%9a%e7%ba%bf%e7%a8%8b/" class="tag-cloud-link tag-link-197 tag-link-position-44" style="font-size: 9.719298245614pt;" aria-label="多线程 (10个项目)" target="_blank" rel="noopener">多线程</a><br><a href="http://ifeve.com/tag/%e5%b9%b6%e5%8f%91%e8%af%91%e6%96%87%ef%bc%8cjava-%ef%bc%8cmaven/" class="tag-cloud-link tag-link-1034 tag-link-position-45" style="font-size: 16.228070175439pt;" aria-label="并发译文，Java ，Maven (36个项目)" target="_blank" rel="noopener">并发译文，Java ，Maven</a></div><br></div><br> </div><br></div><br><div id="side_bottom"><br> <div class="widget_text side_box widget_custom_html" id="custom_html-2"><br><div class="textwidget custom-html-widget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br><!-- 摩天大楼 --><br><ins class="adsbygoogle" style="display:inline-block;width:300px;height:600px" data-ad-client="ca-pub-9394337417063147" data-ad-slot="6358703113" data-adsbygoogle-status="done"><ins id="aswift_3_expand" style="display:inline-table;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:300px;background-color:transparent;"><ins id="aswift_3_anchor" style="display:block;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:300px;background-color:transparent;"><iframe width="300" height="600" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_3" name="aswift_3" style="left:0;position:absolute;top:0;border:0px;width:300px;height:600px;"></iframe></ins></ins></ins><br><script><br>(adsbygoogle = window.adsbygoogle || []).push({});<br></script><br><br><!-- 
<script type="text/javascript">
    /*自适应 创建于 June 30, 2016*/
    var cpro_id = "u2690738";

<script type="text/javascript" src="http://cpro.baidustatic.com/cpro/ui/i.js"></script>
 --><br><br><!-- CNZZ --><br><script src="http://s22.cnzz.com/stat.php?id=5003572&amp;web_id=5003572&amp;show=pic" language="JavaScript"></script><script src="http://c.cnzz.com/core.php?web_id=5003572&amp;show=pic&amp;t=z" charset="utf-8" type="text/javascript"></script><a href="http://www.cnzz.com/stat/website.php?web_id=5003572" target="_blank" title="站长统计"><img border="0" hspace="0" vspace="0" src="http://icon.cnzz.com/img/pic.gif"></a></div></div><br></div>

<p>  </p>
  <div id="footer"><br><br><ul id="copyright"><br>    <li>版权所有 ©&nbsp; <a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a></li><br>    <li>ICP号: <a href="http://www.miibeian.gov.cn" target="_blank">浙ICP备12046809号</a></li><br> <li><br><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602005873" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="" style="float:left;">浙公网安备 33010602005873号</a></li><br>   </ul><br><br><br><br> </div>


<p> </p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JAVA并发/" rel="tag"># JAVA并发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/30/JAVA并发指南1-Java多线程与并发基础/" rel="next" title="JAVA并发指南1-Java多线程与并发基础">
                <i class="fa fa-chevron-left"></i> JAVA并发指南1-Java多线程与并发基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MDkxNy8xNzQ0Mg=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">leslie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">深入理解Java内存模型（一）——基础</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">并发编程模型的分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">Java内存模型的抽象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">重排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">处理器重排序与内存屏障指令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">happens-before</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">参考文献</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">关于作者</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">程晓明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">Latest posts by 程晓明 (see all)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">Related posts:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">近期文章</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">热门文章</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">5.</span> <span class="nav-text">分类目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">6.</span> <span class="nav-text">标签</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"> &copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leslie</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  
    <script type="text/javascript">
      window.livereOptions = {
        refer: '2018/11/30/JAVA并发指南2-深入理解Java内存模型JMM/'
      };
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
