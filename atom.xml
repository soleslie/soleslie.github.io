<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leslie的博客</title>
  
  <subtitle>当你奋力前行时，全世界都会为你让路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://soleslie.github.io/"/>
  <updated>2018-11-19T05:28:27.115Z</updated>
  <id>https://soleslie.github.io/</id>
  
  <author>
    <name>leslie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer</title>
    <link href="https://soleslie.github.io/2018/11/19/%E5%89%91%E6%8C%87offer%E2%80%94%E2%80%94day01/"/>
    <id>https://soleslie.github.io/2018/11/19/剑指offer——day01/</id>
    <published>2018-11-19T02:36:36.000Z</published>
    <updated>2018-11-19T05:28:27.115Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer的实现 参考文章<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md" target="_blank" rel="noopener">传送门</a><br><a id="more"></a><br><!-- GFM-TOC --></p><ul><li><a href="#1-数组中重复的数字">1. 数组中重复的数字</a></li><li><a href="#2-二维数组的查找">2. 二维数组中的查找</a></li><li><a href="#3-替换空格">3. 替换空格</a></li><li><a href="#4-从尾到头打印链表">4. 从尾到头打印链表</a></li><li><a href="#5-重建二叉树">5. 重建二叉树</a><!-- GFM-TOC --></li></ul><h1 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1. 数组中重复的数字"></a>1. 数组中重复的数字</h1><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;2, 3, 1, 0, 2, 5&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求复杂度为 O(N) + O(1)，也就是时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。牛客网讨论区这一题的首票答案使用 nums[i] + length 来将元素标记，这么做会有加法溢出问题。</p><p>这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上。</p><p>以 (2, 3, 1, 0, 2, 5) 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position-0 : (2,3,1,0,2,5) // 2 &lt;-&gt; 1</span><br><span class="line">             (1,3,2,0,2,5) // 1 &lt;-&gt; 3</span><br><span class="line">             (3,1,2,0,2,5) // 3 &lt;-&gt; 0</span><br><span class="line">             (0,1,2,3,2,5) // already in position</span><br><span class="line">position-1 : (0,1,2,3,2,5) // already in position</span><br><span class="line">position-2 : (0,1,2,3,2,5) // already in position</span><br><span class="line">position-3 : (0,1,2,3,2,5) // already in position</span><br><span class="line">position-4 : (0,1,2,3,2,5) // nums[i] == nums[nums[i]], exit</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span>  <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i ,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-二维数组的查找"><a href="#2-二维数组的查找" class="headerlink" title="2. 二维数组的查找"></a>2. 二维数组的查找</h1><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="直接暴力-复杂度O-n-2-O-1"><a href="#直接暴力-复杂度O-n-2-O-1" class="headerlink" title="直接暴力 复杂度O(n^2) + O(1)"></a>直接暴力 复杂度O(n^2) + O(1)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。"><a href="#因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。" class="headerlink" title="因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。"></a>因为数组每行从左到右递增，从上到下递增。所以右上角的第一个数左边的书都比它小，下边的数都比他大。所以可以从右上角开始查找。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span> || array == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = array.length , cols = array[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; row &amp;&amp; c &gt;=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[r][c] == target) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[r][c] &gt; target) c--;</span><br><span class="line">        <span class="keyword">else</span> r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3. 替换空格"></a>3. 替换空格</h1><p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串中的空格替换成 “%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;We Are Happy&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;We%20Are%20Happy&quot;</span><br></pre></td></tr></table></figure><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接暴力如果是空格则添加不是则保留 复杂度O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    StringBuilder newStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">            newStr.append(<span class="string">'%'</span>);</span><br><span class="line">            newStr.append(<span class="string">'2'</span>);</span><br><span class="line">            newStr.append(<span class="string">'0'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newStr.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-从尾到头打印链表"><a href="#4-从尾到头打印链表" class="headerlink" title="4. 从尾到头打印链表"></a>4. 从尾到头打印链表</h1><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入链表的第一个节点，从尾到头反过来打印出每个结点的值。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-使用栈"><a href="#1-使用栈" class="headerlink" title="(1)使用栈"></a>(1)使用栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123; </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        list.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### (2)使用递归</span><br><span class="line">```java</span><br><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123; </span><br><span class="line">    ArrayList&lt;Integr&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">        list.add(listNode.val);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer的实现 参考文章&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://soleslie.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章——对象的共享</title>
    <link href="https://soleslie.github.io/2018/11/18/%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>https://soleslie.github.io/2018/11/18/第三章/</id>
    <published>2018-11-18T06:33:31.000Z</published>
    <updated>2018-11-18T08:16:06.160Z</updated>
    
    <content type="html"><![CDATA[<p>第二章的开头曾指出，要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要正确的管理。第二章介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据，而本章将介绍如何共享和发布对象，从而是他们能够安全地由多个线程同时访问。<br><a id="more"></a></p><h1 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h1><p>可见性是一种复杂的属性， 因为可见性中的错误总会违背我们的直觉。为了确保线程之间对内存的写入操作的可见性，必须使用同步机制。</p><pre><code>public class NoVisibility {    private static boolean ready;    private static int number;    private static class ReaderThread extends Thread {        @Override        public void run() {            while(!ready) {                Thread.yield();                System.out.println(number);            }        }    }    public static void main(String[] args) {        new ReaderThead().start();        number = 42;        ready = true;    }</code></pre><p>}</p><h2 id="3-1-1-失效数据"><a href="#3-1-1-失效数据" class="headerlink" title="3.1.1 失效数据"></a>3.1.1 失效数据</h2><p>Novisibility中展示了在缺乏同步的程序中可能产生错误结果的一种情况：失效数据源。</p><h2 id="3-1-2-非原子的64位操作"><a href="#3-1-2-非原子的64位操作" class="headerlink" title="3.1.2 非原子的64位操作"></a>3.1.2 非原子的64位操作</h2><p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性也被称为最低安全性。</p><p>最低安全性适用于绝大多数的变量，但是有一个例外：非volatile类型的64位的数值变量(double、long)。对于非volatile类型的long和double变量的读取和写入是非原子的。</p><h2 id="3-1-3-加锁与可见性"><a href="#3-1-3-加锁与可见性" class="headerlink" title="3.1.3 加锁与可见性"></a>3.1.3 加锁与可见性</h2><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能够看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在一个锁上进行同步。</p><h2 id="3-1-4-volatile变量"><a href="#3-1-4-volatile变量" class="headerlink" title="3.1.4 volatile变量"></a>3.1.4 volatile变量</h2><p>在访问volatile变量时不会执行加锁操作，因此也就不会执行线程阻塞，因此volatile时是一种比synchronized关键字更轻量的同步机制。</p><p>volatile变量通常用作标志位，标识状态的改变。但是volatile的语义不足以确保递增操作(count++)的原子性，原子变量提供了”读-改-写”的原子操作，常常用作一种更好的”volatile”变量。</p><p>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。</p><h1 id="3-2-发布与溢出"><a href="#3-2-发布与溢出" class="headerlink" title="3.2 发布与溢出"></a>3.2 发布与溢出</h1><p>“发布”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布改对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就称为溢出。</p><p>对于类中外部方法(既不是私有的方法也不是终结final方法)，当把一个对象传递给某个外部方法，就相当于发布了这个对象。</p><p>this引用溢出的详细介绍：<a href="https://blog.csdn.net/flysqrlboy/article/details/10607295" target="_blank" rel="noopener">传送门</a></p><h1 id="3-3-线程封闭"><a href="#3-3-线程封闭" class="headerlink" title="3.3 线程封闭"></a>3.3 线程封闭</h1><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术称为线程封闭，它是实现线程安全性的最简单方式之一</p><h2 id="3-3-1-Ad-hoc线程封闭"><a href="#3-3-1-Ad-hoc线程封闭" class="headerlink" title="3.3.1 Ad-hoc线程封闭"></a>3.3.1 Ad-hoc线程封闭</h2><p>Ad-hoc线程封闭是指，维护线程的封闭性的职责完全由程序实现来承担。不推荐使用</p><h2 id="3-3-2-栈封闭"><a href="#3-3-2-栈封闭" class="headerlink" title="3.3.2 栈封闭"></a>3.3.2 栈封闭</h2><p>栈封闭是线程封闭的一种特列，在栈封闭中，只有通过局部变量才能访问对象。</p><h2 id="3-3-3-ThreadLocal类-看源码"><a href="#3-3-3-ThreadLocal类-看源码" class="headerlink" title="3.3.3 ThreadLocal类(看源码)"></a>3.3.3 ThreadLocal类(看源码)</h2><p>使用线程封闭的一种更规范的方法是ThreadLocal，这个类能使线程的某个值与保存值得对象关联起来。ThreadLocal提供了get和set等访问接口的方法，这些方法位每个使用该变量的线程都存有一份独立的副本，因此get方法总能返回由当前线在tiaoyongset设置的最新值。</p><p>ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。</p><h1 id="3-4-不变性"><a href="#3-4-不变性" class="headerlink" title="3.4 不变性"></a>3.4 不变性</h1><p>满足同步需求的另一种方法是使用不可变对象。如果某个对象在被创建以后其状态不可改变，那么这个对象就被称为不可变对象。不可变对象一定线程安全的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章的开头曾指出，要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要正确的管理。第二章介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据，而本章将介绍如何共享和发布对象，从而是他们能够安全地由多个线程同时访问。&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发编程实战" scheme="https://soleslie.github.io/categories/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
  </entry>
  
  <entry>
    <title>java多线程 (二) ——创建与启动</title>
    <link href="https://soleslie.github.io/2018/11/15/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>https://soleslie.github.io/2018/11/15/java多线程-二-创建与启动/</id>
    <published>2018-11-15T07:12:08.000Z</published>
    <updated>2018-11-15T07:45:09.895Z</updated>
    
    <content type="html"><![CDATA[<p>一、定义线程<br>1、扩展java.lang.Thread类</p><p>此类中有个run()方法，应该注意其用法：</p><pre><code>public void run()如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。Thread 的子类应该重写该方法。</code></pre><a id="more"></a><p>2、实现java.lang.Runnable接口</p><pre><code>void run()使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run 方法。方法 run 的常规协定是，它可能执行任何所需的操作。</code></pre><p>二、实例化线程</p><pre><code>1、如果是扩展java.lang.Thread类的线程，则直接new即可。2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法：Thread(Runnable target)Thread(Runnable target, String name)Thread(ThreadGroup group, Runnable target)Thread(ThreadGroup group, Runnable target, String name)Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code></pre><p>三、启动线程</p><p>在线程的Thread对象上调用start()方法，而不是run()或者别的方法。</p><p>在调用start()方法之前：线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。</p><p>在调用start()方法之后：发生了一系列复杂的事情</p><p>启动新的执行线程（具有新的调用栈）；</p><p>该线程从新状态转移到可运行状态；</p><p>当该线程获得机会执行时，其目标run()方法将运行。</p><p>注意：对Java来说，run()方法没有任何特别之处。像main()方法一样，它只是新线程知道调用的方法名称(和签名)。因此，在Runnable上或者Thread上调用run方法是合法的。但并不启动新的线程。<br>四、例子<br>1、实现Runnable接口的多线程例子</p><pre><code>/** * 实现Runnable接口的类 * * @author leizhimin 2008-9-13 18:12:10 */     public class DoSomething implements Runnable {         private String name;     public DoSomething(String name) {         this.name = name;     }     public void run() {      for (int i = 0; i &lt; 5; i++) {         for (long k = 0; k &lt; 100000000; k++) ;         System.out.println(name + &quot;: &quot; + i);     } } }/** * 测试Runnable类实现的多线程程序 * * @author leizhimin 2008-9-13 18:15:02 */ public class TestRunnable {     public static void main(String[] args) {         DoSomething ds1 = new DoSomething(&quot;阿三&quot;);         DoSomething ds2 = new DoSomething(&quot;李四&quot;);         Thread t1 = new Thread(ds1);         Thread t2 = new Thread(ds2);         t1.start();         t2.start();     } }</code></pre><p>执行结果：</p><p>李四: 0<br>阿三: 0<br>李四: 1<br>阿三: 1<br>李四: 2<br>李四: 3<br>阿三: 2<br>李四: 4<br>阿三: 3<br>阿三: 4<br>Process finished with exit code 0</p><p>2、扩展Thread类实现的多线程例子</p><pre><code>/** * 测试扩展Thread类实现的多线程程序 * * @author leizhimin 2008-9-13 18:22:13 */ public class TestThread extends Thread{     public TestThread(String name) {         super(name);     }     public void run() {         for(int i = 0;i&lt;5;i++){             for(long k= 0; k &lt;100000000;k++);             System.out.println(this.getName()+&quot; :&quot;+i);         }     }     public static void main(String[] args) {         Thread t1 = new TestThread(&quot;阿三&quot;);         Thread t2 = new TestThread(&quot;李四&quot;);         t1.start();         t2.start();     } }</code></pre><p>执行结果：</p><p>阿三 :0<br>李四 :0<br>阿三 :1<br>李四 :1<br>阿三 :2<br>李四 :2<br>阿三 :3<br>阿三 :4<br>李四 :3<br>李四 :4<br>Process finished with exit code 0</p><p>对于上面的多线程程序代码来说，输出的结果是不确定的。其中的一条语句for(long k= 0; k &lt;100000000;k++);是用来模拟一个非常耗时的操作的。<br>五、一些常见问题</p><p>1、线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。</p><p>2、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。</p><p>3、获取当前线程的对象的方法是：Thread.currentThread()；</p><p>4、在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。</p><p>5、当线程目标run()方法结束时该线程完成。</p><p>6、一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。</p><p>7、线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。</p><p>众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。</p><p>8、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列唱呢个一个队列的事实。</p><p>9、尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、定义线程&lt;br&gt;1、扩展java.lang.Thread类&lt;/p&gt;
&lt;p&gt;此类中有个run()方法，应该注意其用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void run()

如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。

Thread 的子类应该重写该方法。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="java多线程" scheme="https://soleslie.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="-多线程 -并发" scheme="https://soleslie.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java多线程 (一) ——概念和原理</title>
    <link href="https://soleslie.github.io/2018/11/13/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80-%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://soleslie.github.io/2018/11/13/java多线程-一-——概念和原理/</id>
    <published>2018-11-13T05:51:20.000Z</published>
    <updated>2018-11-15T06:36:48.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、操作系统中进程和线程的概念"><a href="#一、操作系统中进程和线程的概念" class="headerlink" title="一、操作系统中进程和线程的概念"></a>一、操作系统中进程和线程的概念</h1><p>现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。</p><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。<br><a id="more"></a><br>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。</p><p>“同时”执行是人的感觉，在线程之间实际上轮换执行。 </p><h1 id="二、Java中的线程"><a href="#二、Java中的线程" class="headerlink" title="二、Java中的线程"></a>二、Java中的线程</h1><p>在Java中，线程可以代指两件不同的事情</p><ol><li>java.lang.Thread 的一个实例</li><li>线程的运行</li></ol><p>java线程的基本知识:</p><p>使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。</p><p>一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。</p><p>Java中，每个线程都有一个调用栈。 </p><p>一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。</p><p>一旦创建一个新的线程，就产生一个新的调用栈。</p><p>线程总体分两类：用户线程和守护线程。</p><p>当所有用户线程执行完毕的时候，JVM自动关闭。但是守护线程却不独立于JVM，守护线程一般是由操作系统或者用户自己创建的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、操作系统中进程和线程的概念&quot;&gt;&lt;a href=&quot;#一、操作系统中进程和线程的概念&quot; class=&quot;headerlink&quot; title=&quot;一、操作系统中进程和线程的概念&quot;&gt;&lt;/a&gt;一、操作系统中进程和线程的概念&lt;/h1&gt;&lt;p&gt;现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。&lt;/p&gt;
&lt;p&gt;进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。&lt;br&gt;
    
    </summary>
    
      <category term="java多线程" scheme="https://soleslie.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://soleslie.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://soleslie.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>leslie</title>
    <link href="https://soleslie.github.io/2018/11/09/leslie/"/>
    <id>https://soleslie.github.io/2018/11/09/leslie/</id>
    <published>2018-11-09T08:56:28.000Z</published>
    <updated>2018-11-16T02:59:38.444Z</updated>
    
    <content type="html"><![CDATA[<p>时间是个让人触不及防的东西，真的没想到我竟然快要毕业了，仿佛一切都还刚发生，好像我还是那个高考失败发誓要在大学里面好好学习的高中生，一切都好像历历在目。可是我好像又失败了，在大学也没好好学习。我还依稀记得我在高考失败信誓旦旦的说我一定会好好学习的，我也不知道多少个夜晚我都发誓说要好好学习，可第二天它就被我抛弃了。可是直到找工作的时候，我才明白自己的处境，知道自己是那么的不堪。“不优秀不可怕，可怕的是知道自己不优秀还不努力”这句话应该就是我真实的写照吧。</p><p>回首大学岁月，让我最后悔的就是放弃acm吧，让我现在离梦想那么远，跟别人差距那么大，我羡慕别人，可是发现这一切都是我应得的。你有多努力，就有多幸运。我倒下了。哦，对了，大学没谈一场轰天动地的恋爱也是很遗憾啊，也许这辈子就单身了。哈哈哈哈哈哈</p><p>奉劝各位还在读大学的象牙塔的学生们，该学习的时候一定好好学习，顺便谈一场属于自己的学生时代的恋爱。</p><pre><code>Hello World 不知道现在努力还来的及码？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间是个让人触不及防的东西，真的没想到我竟然快要毕业了，仿佛一切都还刚发生，好像我还是那个高考失败发誓要在大学里面好好学习的高中生，一切都好像历历在目。可是我好像又失败了，在大学也没好好学习。我还依稀记得我在高考失败信誓旦旦的说我一定会好好学习的，我也不知道多少个夜晚我都发
      
    
    </summary>
    
      <category term="-大学生活" scheme="https://soleslie.github.io/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
</feed>
